<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoMarket: Del Productor/Consumidor al Pub/Sub - Eventos que Conectan Servicios</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
            border-bottom: 3px solid #e74c3c;
            padding-bottom: 10px;
        }
        .phase {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .phase h2 {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .phase h2::before {
            content: attr(data-icon);
            font-size: 1.5em;
            margin-right: 10px;
        }
        .activity {
            background: #e8f4fd;
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .checkpoint {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
        }
        .code-python {
            background: #f0f0f0;
            border-left: 4px solid #3572A5;
        }
        .code-csharp {
            background: #f0f0f0;
            border-left: 4px solid #9B4F96;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin: 5px 0;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .tip {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .reflection {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .evolution-step {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
        }
        .evolution-step::after {
            content: "â†“";
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #e74c3c;
        }
        .evolution-step:last-child::after {
            display: none;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            background: white;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .comparison-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .decision-matrix {
            background: #fff;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .ai-prompt {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
        }
        .progress-item {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: #e9ecef;
            margin: 0 5px;
            border-radius: 5px;
        }
        .progress-item.active {
            background: #e74c3c;
            color: white;
        }
        .scenario-box {
            background: #f0f8ff;
            border: 1px solid #e74c3c;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .diagram {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            overflow-x: auto;
        }
        .dual-lang {
            display: flex;
            gap: 20px;
        }
        .dual-lang > div {
            flex: 1;
        }
        @media (max-width: 768px) {
            .dual-lang {
                flex-direction: column;
            }
        }
    </style>
	<script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({ startOnLoad: true, theme: 'default' });</script>
</head>
<body>
    <h1>EcoMarket: Del Productor/Consumidor al Pub/Sub - Eventos que Conectan Servicios</h1>
    <p>De colas puntuales a arquitecturas basadas en eventos: Evoluciona tu sistema de usuarios con RabbitMQ Fanout Exchange</p>

    <!-- SecciÃ³n de IntroducciÃ³n -->
    <section id="introduccion" style="background: #f0f8ff; border-radius: 10px; padding: 20px; margin: 20px 0;">
        <h2>ğŸ¯ Al Final de Esta Semana, SerÃ¡s Capaz De:</h2>
        <div class="checkpoint">
            <ul>
                <li>âœ… <strong>Implementar</strong> un publisher que emita eventos a RabbitMQ con exchange fanout</li>
                <li>âœ… <strong>Crear</strong> 2+ consumers independientes que reaccionen al mismo evento</li>
                <li>âœ… <strong>Demostrar</strong> desacoplamiento: agregar un consumer sin modificar el publisher</li>
                <li>âœ… <strong>Simular</strong> y recuperar de fallos de un consumer (prueba de caos)</li>
                <li>âœ… <strong>Justificar</strong> cuÃ¡ndo usar Pub/Sub vs colas punto-a-punto (con nÃºmeros)</li>
                <li>âœ… <strong>Diagramar</strong> el flujo de eventos en tu sistema distribuido</li>
            </ul>
        </div>

        
		<h2>ğŸ“š Lecturas / Estudio Independiente (Antes del Taller)</h2>
<p>Prepara el terreno con estas lecturas (30-45 min):</p>
<ul>
    <li><a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/integration-event-based-microservice-communications" target="_blank">"Implementing event-based communication between microservices" (Microsoft Docs)</a> â€“ EnfÃ³cate en Pub/Sub con .NET y event bus.<grok-card data-id="24887d" data-type="citation_card"></grok-card></li>
    <li><a href="https://medium.com/@hashirkhanps/mastering-event-driven-architecture-with-c-and-net-4c71214a1c03" target="_blank">"Mastering Event-Driven Architecture with C# and .NET" (Medium, 2025)</a> â€“ Ejemplos prÃ¡cticos con RabbitMQ.<grok-card data-id="2d2394" data-type="citation_card"></grok-card></li>
    <li><a href="https://docs.dapr.io/developing-applications/building-blocks/pubsub/pubsub-overview/" target="_blank">Ejemplos de Pub/Sub en .NET (Dapr)</a> â€“ Para ver cÃ³digo de referencia simple.<grok-card data-id="7c20d3" data-type="citation_card"></grok-card></li>
</ul>

        <h2>ğŸ› ï¸ Taller 4: ImplementaciÃ³n de un Sistema de Eventos en EcoMarket</h2>
        <p><strong>Instrucciones (4 horas):</strong> Evoluciona tu proyecto de Semana 3 (colas para ventas) agregando eventos para usuarios. Muestra ejemplos en Python (continuidad) y C# (exploraciÃ³n).</p>
        <ol>
            <li>Adapta el servicio de usuarios (de Taller 2) para que, al crear un usuario vÃ¡lido, publique un evento `UsuarioCreado` al bus (usa RabbitMQ de Taller 3).</li>
            <li>Construye un servicio **NotificacionesService** que se suscriba al evento `UsuarioCreado` y envÃ­e un email simulado (print o SMTP real).</li>
            <li><strong>Opcional/Reto:</strong> Crea **EstadÃ­sticasService** para contar usuarios nuevos.</li>
            <li>Verifica independencia: Agrega un suscriptor sin tocar el publisher.</li>
        </ol>

        <h3>Requisitos TÃ©cnicos MÃ­nimos</h3>
        <ul>
            <li>Usa RabbitMQ (reutiliza setup de Taller 3).</li>
            <li>Define contrato: Clase `UsuarioCreadoEvent` con Id, Nombre, Email (en C#) o dict equivalente (Python).</li>
            <li>Suscriptores validan datos del evento.</li>
            <li>Manejo de fallos: Reintentos o Dead-Letter Queue (DLQ).</li>
        </ul>

        <div class="tip">
            <h3>ğŸ”§ Â¿Por QuÃ© RabbitMQ para Este Taller?</h3>
            <p><strong>Para producciÃ³n real, considera:</strong></p>
            <ul>
                <li><strong>RabbitMQ</strong>: âœ… Elegido aquÃ­ - fÃ¡cil setup, buena documentaciÃ³n, gratis, ideal para aprender</li>
                <li><strong>Kafka</strong>: Mejor para high-throughput (>100k eventos/seg), mÃ¡s complejo de configurar</li>
                <li><strong>Azure Service Bus</strong>: Si ya estÃ¡s en Azure, integraciÃ³n nativa con .NET</li>
                <li><strong>Redis Pub/Sub</strong>: MÃ¡s simple, pero sin persistencia (solo para pruebas ligeras)</li>
            </ul>
            <p><strong>Para aprender el patrÃ³n Pub/Sub, RabbitMQ es ideal â­</strong> - Balance perfecto entre funcionalidad y complejidad.</p>
        </div>

        <h3>ğŸ“Š Esquema de Componentes Propuesto</h3>
        <div class="diagrama">
            <pre style="background: #f7f7f7; border: 1px solid #ccc; padding: 10px; overflow-x: auto; font-size: 0.9em;">
			<div class="mermaid">
%%{ init: { "flowchart": { "htmlLabels": true } } }%%
graph LR
  A["UsuarioService<br>(Publisher)"] -->|Publica UsuarioCreado| B["RabbitMQ<br>(Fanout Exchange)"]
  B -->|Broadcast| C["NotificacionesService<br>(Subscriber)"]
  B -->|Broadcast| D["EstadÃ­sticasService<br>(Subscriber Opcional)"]
  style A fill:#e8f4fd
  style B fill:#d1ecf1
  style C fill:#e8f5e8
  style D fill:#f8f0e8

	</div>
            </pre>
            <p><em>Diagrama Mermaid: Publisher â†’ Bus â†’ MÃºltiples Suscriptores independientes.</em></p>
        </div>

        <h2>ğŸ“‹ Entrega y EvaluaciÃ³n (Hito 1 - 15%)</h2>
        <ul>
            <li><strong>Repositorio:</strong> CÃ³digo con servicios (GitHub o similar).</li>
            <li><strong>Diagrama:</strong> Flujo de eventos (extiende el de arriba).</li>
            <li><strong>Informe breve (1-2 pÃ¡ginas):</strong>
                <ul class="variants">
                    <li>JustificaciÃ³n de Pub/Sub: Ventajas (desacoplamiento, escalabilidad) vs retos (eventual consistency).</li>
                    <li>Desacoplamiento logrado: Ej. agregar suscriptor sin cambios en publisher.</li>
                    <li>Mejoras futuras: MÃ¡s eventos, versionado, monitoreo (e.g., con Prometheus).</li>
                </ul>
            </li>
        </ul>
        <div class="tip">
            <strong>Tip para entrega:</strong> Incluye un README con comandos para correr (e.g., docker-compose up) y un video corto (1 min) de E2E: Crear usuario â†’ Ver logs en suscriptores.
        </div>

        <h2>ğŸ¤” Cuestiones de ReflexiÃ³n (Post-Taller)</h2>
        <ol>
            <li>Â¿QuÃ© pasa si un suscriptor cae? Â¿CÃ³mo aseguras no perder eventos? (Persistencia en queues, DLQ, reintentos).</li>
            <li>Â¿CÃ³mo versionar eventos si agregas campos? (Backward compatibility, schemas con Avro/Protobuf).</li>
            <li>Â¿Consideraciones de seguridad? (AutenticaciÃ³n en bus, validaciÃ³n de eventos, encriptaciÃ³n).</li>
            <li>Â¿CuÃ¡ndo evitar Pub/Sub? (Operaciones transaccionales sÃ­ncronas, baja latencia crÃ­tica).</li>
        </ol>
        <p><strong>Â¡Ahora, salta al Journey de EcoMarket para la prÃ¡ctica guiada!</strong> <a href="#journey" style="color: #e74c3c; font-weight: bold;">Ir al Journey â†’</a></p>
    </section>

    <div id="journey"></div>

    <div class="progress-bar">
        <div class="progress-item active">ğŸ¯ Fase 0: El Problema Real</div>
        <div class="progress-item">ğŸ”„ Fase 1: EvoluciÃ³n de Soluciones</div>
        <div class="progress-item">ğŸ’» Fase 2: Implementando Pub/Sub</div>
        <div class="progress-item">ğŸ§ª Fase 3: ValidaciÃ³n</div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸ¯">Fase 0: El Problema Real que Justifica Pub/Sub (30 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Entender por quÃ© el Productor/Consumidor simple no escala para mÃºltiples suscriptores. Justifica la complejidad de eventos con nÃºmeros del negocio.</p>

        <h3>ğŸª´ Escenario: Evoluciona tu Servicio de Usuarios (IntegraciÃ³n con Semanas 1-3)</h3>
        <p>Usa el servicio de registro de usuarios ya implementado (de Taller 1-2). Ahora, al crear un usuario, necesitas notificar a mÃºltiples servicios (email, lealtad, analÃ­tica) sin acoplamiento sÃ­ncrono.</p>

        <div class="scenario-box">
            <h4>ğŸ“Š Datos Reales del Sistema Actual:</h4>
            <ul>
                <li><strong>Volumen:</strong> 100 registros de usuarios por hora en picos</li>
                <li><strong>Suscriptores:</strong> 3 servicios (email, loyalty, analytics)</li>
                <li><strong>Acoplamiento actual:</strong> Cada suscriptor consulta directamente el servicio de registro (HTTP sÃ­ncrono, de Taller 2)</li>
                <li><strong>Fallos:</strong> 5% de notificaciones fallan por sobrecarga</li>
                <li><strong>Costo de oportunidad:</strong> $50 por usuario perdido en lealtad no activada</li>
            </ul>
        </div>

        <div class="scenario-box">
            <h4>ğŸ“ˆ Diagrama: El Problema Actual con Acoplamiento</h4>
			<div class="mermaid">
%%{ init: { "flowchart": { "htmlLabels": true } } }%%
graph LR
  subgraph RegistroUsuario
    RU[Registro Usuario]
  end

  subgraph Suscriptores
    EmailService[Servicio Email]
    LoyaltyService[Servicio Loyalty]
  end

  EmailService -- "HTTP POST (â‰¤ 200 ms)" --> RU
  RU -- "HTTP POST (â‰¤ 200 ms)" --> LoyaltyService

  RU -. "Si cae â†’ timeout en Email, usuario no recibe bienvenida" .-> EmailService
  RU -. "Si sobrecarga â†’ ambos esperan 500 ms, 5 % fallos" .-> LoyaltyService

  %% Estilos opcionales para visibilidad
  style RU fill:#fefee0,stroke:#999,stroke-width:1px
  style EmailService fill:#e8f4fd
  style LoyaltyService fill:#e8f4fd
  </div>
			
            <pre class="diagram">
SITUACIÃ“N ACTUAL: HTTP SÃNCRONO A MÃšLTIPLES SUSCRIPTORES
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    HTTP POST      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    HTTP POST      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Servicio    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ Registro    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ Servicio    â”‚
â”‚ Email       â”‚ â† 200ms â†’         â”‚ Usuario     â”‚ â† 200ms â†’         â”‚ Loyalty     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                                   â”‚                               â”‚
      â”‚ Si Registro cae:                  â”‚ Si sobrecarga:                â”‚
      â”œâ”€â”€Xâ”€â”€ Timeout en Email             â”‚ â”œâ”€â”€Xâ”€â”€ Email espera 500ms     â”‚
      â”œâ”€â”€Xâ”€â”€ Usuario no recibe bienvenida â”‚ â”œâ”€â”€Xâ”€â”€ Loyalty espera 500ms   â”‚
      â””â”€â”€Xâ”€â”€ $50 perdido en engagement    â”‚ â””â”€â”€Xâ”€â”€ 5% fallos = $250/hora  â”‚

COSTO REAL: 5% fallos Ã— 800 usuarios/dÃ­a Ã— $50 = $2,000 perdidos/dÃ­a
ESCALAMIENTO: +1 suscriptor = +200ms latencia + 20% mÃ¡s carga en Registro
            </pre>
        </div>

        <div class="warning">
            <h3>âš ï¸ Los SÃ­ntomas del Dolor</h3>
            <p><strong>Reporte del Gerente:</strong> "Los nuevos usuarios no reciben emails de bienvenida en un 15% de los casos, y el programa de lealtad no se activa automÃ¡ticamente."</p>
            <p><strong>Reporte TÃ©cnico:</strong> El servicio de registro se sobrecarga llamando a 3 endpoints HTTP por usuario, tardando 600ms en total.</p>
            <p><strong>Impacto:</strong> 15% Ã— 800 usuarios/dÃ­a Ã— $50 = $6,000 perdidos en engagement mensual.</p>
        </div>

        <div class="activity">
            <h3>ğŸ§® Actividad: Calculando el Costo de Acoplamiento</h3>
            <p><strong>Objetivo:</strong> Cuantificar por quÃ© necesitas desacoplamiento vÃ­a eventos.</p>
            <ol>
                <li><strong>Calcula:</strong> Con 5% fallos y 800 usuarios/dÃ­a, Â¿cuÃ¡nto en engagement perdido al mes?</li>
                <li><strong>Proyecta:</strong> Si agregas 2 suscriptores mÃ¡s, Â¿cÃ³mo escala la latencia y fallos?</li>
                <li><strong>Umbral:</strong> Â¿A partir de quÃ© costo mensual inviertes en Pub/Sub?</li>
            </ol>
            <p><strong>Meta:</strong> Justificar Pub/Sub con ROI concreto.</p>
        </div>

        <div class="ai-prompt">
            <h4>ğŸ¤– Prompt para IA: AnÃ¡lisis de Impacto de Acoplamiento</h4>
            <pre>AyÃºdame a analizar el impacto de acoplamiento sÃ­ncrono en mi sistema de usuarios:

Contexto:
- Registros por dÃ­a: 800
- Valor por usuario activado: $50
- Tasa de fallos actual: 5%
- Suscriptores: 3 servicios (email, loyalty, analytics)
- Latencia por llamada HTTP: 200ms

Preguntas:
1. Â¿CuÃ¡l es el costo mensual de fallos en engagement?
2. Si agrego 2 suscriptores, Â¿cÃ³mo escala el problema?
3. Â¿A partir de quÃ© punto el acoplamiento se vuelve crÃ­tico?
4. Â¿QuÃ© costos ocultos (e.g., mantenimiento) estoy ignorando?

Dame nÃºmeros y escenarios concretos.</pre>
        </div>

        <div class="checkpoint">
            <h3>âœ… Checkpoint de Fase 0</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Criterio</th>
                        <th>Â¿Cumple?</th>
                        <th>Evidencia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>CalculÃ© costo mensual de acoplamiento</td>
                        <td>â–¡ SÃ­ / â–¡ No</td>
                        <td>NÃºmero: $______ /mes</td>
                    </tr>
                    <tr>
                        <td>IdentifiquÃ© umbral para Pub/Sub</td>
                        <td>â–¡ SÃ­ / â–¡ No</td>
                        <td>Si > $______, invierto en eventos</td>
                    </tr>
                    <tr>
                        <td>Entiendo por quÃ© colas punto-a-punto no escalan</td>
                        <td>â–¡ SÃ­ / â–¡ No</td>
                        <td>Explico 2 limitaciones</td>
                    </tr>
                    <tr>
                        <td>ConectÃ© con proyecto previo (ventas)</td>
                        <td>â–¡ SÃ­ / â–¡ No</td>
                        <td>IdentifiquÃ© patrÃ³n similar</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸ”„">Fase 1: La EvoluciÃ³n Natural hacia Eventos (45 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Explora cÃ³mo el Productor/Consumidor evoluciona a Pub/Sub, entendiendo lÃ­mites de cada paso.</p>

        <h3>ğŸš€ El Evolution Journey a Eventos</h3>
        <p>No saltas directo a Pub/Sub. Evolucionas cuando el acoplamiento duele, extendiendo las colas de Taller 3.</p>

        <div class="scenario-box">
            <h4>ğŸ”„ Diagrama: Evolution Journey - De Punto-a-Punto a Eventos</h4>
			
            <pre class="diagram">
PASO 1: HTTP SÃNCRONO MÃšLTIPLES LLAMADAS
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€HTTPâ†’  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€HTTPâ†’  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Registro â”‚           â”‚ Email   â”‚           â”‚ Loyalty â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“ Problema: 600ms latencia + sobrecarga

PASO 2: COLA PUNTO-A-PUNTO (De Taller 3)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€publishâ†’ [Queue Email] â”€â”€consumeâ†’   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Registro â”‚ â”€â”€publishâ†’ [Queue Loyalty] â”€â”€consumeâ†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“ Problema: DuplicaciÃ³n de queues + acoplamiento en routing

PASO 3: PUB/SUB CON EXCHANGE FANOUT
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€publishâ†’ [Fanout Exchange]  â”€â”€bindâ†’ [Queue Email]
â”‚Registro â”‚              "user_events"     â”€â”€bindâ†’ [Queue Loyalty]
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”€â”€bindâ†’ [Queue Analytics]
    â†“ SoluciÃ³n: 1 publish â†’ N consumers, desacoplado

DECISIÃ“N: Â¿Vale Pub/Sub por escalabilidad de suscriptores?
          Si >3 suscriptores o crecimiento â†’ SÃ­
            </pre>
        </div>

        <div class="evolution-step">
            <h4>Paso 1: HTTP SÃ­ncrono MÃºltiples (Actual)</h4>
            <p><strong>CÃ³digo:</strong> Llamadas secuenciales a 3 endpoints</p>
            <p><strong>Funciona cuando:</strong> Pocos suscriptores, red perfecta</p>
            <p><strong>Falla cuando:</strong> Sobrecarga, latencia acumulada</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 2: Colas Punto-a-Punto (Taller 3)</h4>
            <p><strong>CÃ³digo:</strong> Publish separado por queue</p>
            <p><strong>Funciona cuando:</strong> 2-3 suscriptores fijos</p>
            <p><strong>Falla cuando:</strong> Agregar suscriptor = nueva queue + cÃ³digo</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 3: Pub/Sub con Fanout Exchange</h4>
            <p><strong>CÃ³digo:</strong> 1 publish a exchange, bindings automÃ¡ticos</p>
            <p><strong>Funciona cuando:</strong> MÃºltiples suscriptores dinÃ¡micos</p>
            <p><strong>Nuevo costo:</strong> GestiÃ³n de exchanges/bindings</p>
        </div>

        <div class="activity">
            <h3>ğŸ§ª Actividad: Implementando y Rompiendo Cada Paso</h3>
            <p><strong>Objetivo:</strong> Probar lÃ­mites extendiendo Taller 3.</p>

            <h4>Paso 2A: Cola Punto-a-Punto (Extiende Taller 3, 15 min)</h4>
            <div class="dual-lang">
                <div>
                    <h5>Ejemplo en Python</h5>
                    <div class="code-block code-python">
                        <pre># En Servicio Registro (extiende tu cÃ³digo de usuarios)
import pika
import json

def publish_to_email_queue(user_data):
    connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
    channel = connection.channel()
    channel.queue_declare(queue='email_queue', durable=True)
    channel.basic_publish(
        exchange='',
        routing_key='email_queue',
        body=json.dumps(user_data),
        properties=pika.BasicProperties(delivery_mode=2)
    )
    connection.close()

def publish_to_loyalty_queue(user_data):
    # Similar, pero queue='loyalty_queue'
    pass  # DuplicaciÃ³n de cÃ³digo</pre>
                    </div>
                </div>
                <div>
                    <h5>Ejemplo en C# (ExploraciÃ³n)</h5>
                    <div class="code-block code-csharp">
                        <pre>// En UsuarioService (extiende tu proyecto Semana 2)
using RabbitMQ.Client;
using System.Text;
using System.Text.Json;

public void PublishToEmailQueue(UserData userData)
{
    var factory = new ConnectionFactory { HostName = "localhost" };
    using var connection = factory.CreateConnection();
    using var channel = connection.CreateModel();
    
    channel.QueueDeclare(queue: "email_queue", durable: true);
    
    var json = JsonSerializer.Serialize(userData);
    var body = Encoding.UTF8.GetBytes(json);
    
    channel.BasicPublish(exchange: "", routingKey: "email_queue", basicProperties: null, body: body);
}

// Similar para loyalty_queue - DuplicaciÃ³n</pre>
                    </div>
                </div>
            </div>

            <p><strong>Prueba de ruptura:</strong> Agrega un 4to suscriptor. Â¿CuÃ¡nto cÃ³digo nuevo?</p>

            <div class="tip">
                <h4>ğŸ¤” Â¿QuÃ© pasarÃ­a si...?</h4>
                <p><strong>Escenario:</strong> Analytics se une tarde:</p>
                <ul>
                    <li>Crear nueva queue + mÃ©todo publish</li>
                    <li>Modificar Registro â†’ riesgo de regresiÃ³n</li>
                    <li>Acoplamiento: Registro conoce todas las queues</li>
                </ul>
            </div>

            <h4>Paso 2B: Mejora con Routing Keys (10 min)</h4>
            <div class="dual-lang">
                <div>
                    <h5>Ejemplo en Python</h5>
                    <div class="code-block code-python">
                        <pre># Direct Exchange con routing keys
channel.exchange_declare(exchange='user_direct', exchange_type='direct')
channel.basic_publish(
    exchange='user_direct',
    routing_key='user.created.email',  # Routing especÃ­fico
    body=json.dumps(user_data)
)</pre>
                    </div>
                </div>
                <div>
                    <h5>Ejemplo en C#</h5>
                    <div class="code-block code-csharp">
                        <pre>// Direct Exchange con routing keys
channel.ExchangeDeclare("user_direct", ExchangeType.Direct);
var body = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(userData));
channel.BasicPublish("user_direct", "user.created.email", null, body);</pre>
                    </div>
                </div>
            </div>

            <p><strong>Prueba de ruptura:</strong> Â¿Y si un suscriptor quiere mÃºltiples eventos?</p>
        </div>

        <div class="decision-matrix">
            <h3>ğŸ“Š Matriz de DecisiÃ³n: Â¿CuÃ¡ndo usar quÃ©?</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>SoluciÃ³n</th>
                        <th>Complejidad</th>
                        <th>Funciona hasta</th>
                        <th>Falla cuando</th>
                        <th>Costo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>HTTP MÃºltiples</strong></td>
                        <td>Muy Baja</td>
                        <td>2 suscriptores, bajo volumen</td>
                        <td>3+ suscriptores</td>
                        <td>Bajo</td>
                    </tr>
                    <tr>
                        <td><strong>Colas Punto-a-Punto</strong></td>
                        <td>Baja</td>
                        <td>3 suscriptores fijos</td>
                        <td>Agregar dinÃ¡micamente</td>
                        <td>Bajo</td>
                    </tr>
                    <tr>
                        <td><strong>Pub/Sub Fanout</strong></td>
                        <td>Media</td>
                        <td>10+ suscriptores, eventos broadcast</td>
                        <td>Routing selectivo complejo</td>
                        <td>Medio</td>
                    </tr>
                    <tr>
                        <td><strong>Topic Exchange</strong></td>
                        <td>Alta</td>
                        <td>Eventos filtrados por tipo</td>
                        <td>SobreingenierÃ­a para simples</td>
                        <td>Alto</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="ai-prompt">
            <h4>ğŸ¤– Prompt para IA: AnÃ¡lisis de Alternativas Pub/Sub</h4>
            <pre>Analiza alternativas para desacoplar suscriptores en EcoMarket:

Contexto:
- Eventos: UsuarioCreado (broadcast a 3+ servicios)
- Volumen: 800/dÃ­a, creciendo 3x
- Tolerancia: <1% eventos perdidos
- Equipo: 2 devs, RabbitMQ ya en uso

Alternativas:
1. Colas punto-a-punto
2. Fanout Exchange (Pub/Sub simple)
3. Topic Exchange (filtrado)
4. Kafka (avanzado)

EvalÃºa:
- Â¿Cumple actuales?
- Â¿Escala crecimiento?
- Esfuerzo implementaciÃ³n?
- Problemas operacionales?
- Â¿CuÃ¡ndo migrar?

Recomienda para AHORA y upgrade path.</pre>
        </div>

        <div class="reflection">
            <h3>ğŸ¤” Momento de DecisiÃ³n</h3>
            <p><strong>Pregunta equipo:</strong> "Â¿En quÃ© punto del journey estamos forzados a Pub/Sub?"</p>
            <p><strong>Datos:</strong> Costo fallos $X/mes, tiempo impl., complejidad manejable, crecimiento.</p>
        </div>

        <div class="checkpoint">
            <h3>âœ… Checkpoint de Fase 1</h3>
            <ul>
                <li>ImplementÃ©/probÃ© 2 pasos previos</li>
                <li>Entiendo lÃ­mites de cada uno</li>
                <li>JustificaciÃ³n cuantitativa para Pub/Sub</li>
                <li>Explico por quÃ© no es overkill</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸ’»">Fase 2: Implementando Pub/Sub con PropÃ³sito (60 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Implementa Fanout Exchange sabiendo quÃ© problema resuelve: Desacoplamiento para mÃºltiples suscriptores. Usa RabbitMQ (de Taller 3). Ejemplos en Python y C# para continuidad y exploraciÃ³n.</p>

        <div class="tip">
            <h3>ğŸ’¡ Contexto</h3>
            <p>Implementas Pub/Sub porque:</p>
            <ul>
                <li>1 publish â†’ N consumers sin acoplamiento</li>
                <li>Escalabilidad: Agregar suscriptores sin tocar publisher</li>
                <li>Resiliencia: Fallo en un suscriptor no afecta otros</li>
                <li>ROI: Reduce latencia 600ms â†’ 50ms + $6k/mes saved</li>
            </ul>
        </div>

        <div class="activity">
            <h3>ğŸ¬ Demo RÃ¡pida (5 minutos - Hazlo AHORA)</h3>
            <p><strong>Antes de entender todo el cÃ³digo, veamos que funciona:</strong></p>
            
            <ol>
                <li>Inicia RabbitMQ: <code>docker-compose up -d</code> (o inicia el servicio local)</li>
                <li>En terminal 1, corre: <code>python email_consumer_simple.py</code></li>
                <li>En terminal 2, corre: <code>python loyalty_consumer_simple.py</code></li>
                <li>En terminal 3, ejecuta:
                    <div class="code-block">
                        <pre>curl -X POST http://localhost:8000/users \
  -H "Content-Type: application/json" \
  -d '{"email": "test@eco.com", "name": "Juan"}'</pre>
                    </div>
                </li>
                <li><strong>Observa:</strong> En ambos terminales verÃ¡s los logs simultÃ¡neamente:
                    <div class="code-block">
                        <pre>Terminal 1: ğŸ“§ Enviando email a test@eco.com
Terminal 2: ğŸ Activando lealtad para Juan</pre>
                    </div>
                </li>
            </ol>
            
            <div class="checkpoint">
                <p><strong>Â¡Acabas de ver Pub/Sub en acciÃ³n!</strong> Un evento â†’ mÃºltiples reacciones independientes. Ahora entendamos el cÃ³digo...</p>
            </div>
        </div>

        <h3>ğŸ—‚ï¸ Arquitectura con Eventos</h3>

        <div class="scenario-box">
            <h4>ğŸ¯ Diagrama: Arquitectura Pub/Sub - Justificada</h4>
            <pre class="diagram">
ARQUITECTURA CON PUB/SUB PARA EVENTOS DE USUARIOS

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SERVICIO        â”‚                 â”‚        RABBITMQ              â”‚
â”‚ REGISTRO        â”‚                 â”‚                              â”‚
â”‚                 â”‚ â”€â”€publishâ”€â”€â”€â”€â†’  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ 1. Usuario      â”‚   (durable,     â”‚  â”‚ user_events      â”‚        â”‚
â”‚    creado local â”‚    fanout)      â”‚  â”‚ (Fanout Exchange)â”‚ â”€â”€bindâ”€â”€â†’ [Queue Email]
â”‚    (50ms)       â”‚                 â”‚  â”‚ â€¢ Broadcast all  â”‚        â”‚
â”‚                 â”‚                 â”‚  â”‚ â€¢ No routing     â”‚ â”€â”€bindâ”€â”€â†’ [Queue Loyalty]
â”‚ 2. Evento       â”‚                 â”‚  â”‚ â€¢ Durable        â”‚        â”‚
â”‚    inmediato    â”‚                 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ â”€â”€bindâ”€â”€â†’ [Queue Analytics]
â”‚                 â”‚                 â”‚                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                                                              â”‚
      â”‚ GarantÃ­a: Venta NUNCA falla                                  â”‚
      â”‚ por problemas de red                                         â”‚
      â”‚                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                                          â”‚    CENTRAL API          â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DESACOPLAMIENTO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                         â”‚
                                                 â”‚ 1. Consumer robusto     â”‚
                                                 â”‚    â€¢ Idempotencia       â”‚
                                                 â”‚    â€¢ Error handling     â”‚
                                                 â”‚    â€¢ ACK explÃ­cito      â”‚
                                                 â”‚                         â”‚
                                                 â”‚ 2. Actualiza inventario â”‚
                                                 â”‚    â€¢ Solo tras ACK      â”‚
                                                 â”‚    â€¢ Log de auditorÃ­a   â”‚
                                                 â”‚                         â”‚
                                                 â”‚ 3. Escalable           â”‚
                                                 â”‚    â€¢ MÃºltiples workers  â”‚
                                                 â”‚    â€¢ Load balancing     â”‚
                                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

BENEFICIOS ESPECÃFICOS OBTENIDOS:
âœ… Tiempo venta: 3-5s â†’ 50ms (95% mejora)
âœ… Disponibilidad: 98% â†’ 99.9% (10x mejora)  
âœ… PÃ©rdida mensajes: 2% â†’ 0.01% (200x mejora)
âœ… Escalabilidad: 1 sucursal â†’ N sucursales
â— Costo nuevo: Infraestructura + operaciÃ³n RabbitMQ
            </pre>
        </div>

        <div class="activity">
            <h3>ğŸ”„ IntegraciÃ³n con tu CÃ³digo de Semana 2</h3>
            <p><strong>Si ya tienes este endpoint de usuarios (de Taller 2):</strong></p>
            
            <div class="dual-lang">
                <div>
                    <h5>CÃ³digo Actual (Python)</h5>
                    <div class="code-block code-python">
                        <pre>@app.post("/users")
async def create_user(user: UserCreate):
    # Tu lÃ³gica actual de semana 2
    new_user = save_user_to_db(user)
    return {"user_id": new_user.id}</pre>
                    </div>
                </div>
                <div>
                    <h5>CÃ³digo Actual (C#)</h5>
                    <div class="code-block code-csharp">
                        <pre>[HttpPost]
public IActionResult CreateUser([FromBody] UserCreateDto user)
{
    // Tu lÃ³gica actual de semana 2
    var newUser = _userService.SaveUser(user);
    return Ok(new { UserId = newUser.Id });
}</pre>
                    </div>
                </div>
            </div>

            <p><strong>ModifÃ­calo asÃ­ (solo 3 lÃ­neas nuevas):</strong></p>
            
            <div class="dual-lang">
                <div>
                    <h5>Con Eventos (Python)</h5>
                    <div class="code-block code-python">
                        <pre>@app.post("/users")
async def create_user(user: UserCreate, background_tasks: BackgroundTasks):
    new_user = save_user_to_db(user)
    # â¬‡ï¸ NUEVA LÃNEA 1: Importa la funciÃ³n de eventos
    from events import publish_user_created
    # â¬‡ï¸ NUEVA LÃNEA 2: Publica el evento en background
    background_tasks.add_task(
        publish_user_created, 
        {"user_id": new_user.id, "email": user.email}
    )
    return {"user_id": new_user.id}</pre>
                    </div>
                </div>
                <div>
                    <h5>Con Eventos (C#)</h5>
                    <div class="code-block code-csharp">
                        <pre>[HttpPost]
public IActionResult CreateUser([FromBody] UserCreateDto user)
{
    var newUser = _userService.SaveUser(user);
    // â¬‡ï¸ NUEVA LÃNEA 1: Inyecta el publisher
    var publisher = new UserEventPublisher();
    // â¬‡ï¸ NUEVA LÃNEA 2: Publica el evento
    publisher.PublishUserCreated(new UserData 
    { 
        Id = newUser.Id, 
        Email = user.Email 
    });
    return Ok(new { UserId = newUser.Id });
}</pre>
                    </div>
                </div>
            </div>

            <div class="tip">
                <p><strong>Nota:</strong> El evento se publica en background, asÃ­ que la respuesta HTTP es inmediata (50ms) independiente de cuÃ¡ntos suscriptores existan.</p>
            </div>
        </div>

        <div class="activity">
            <h3>ğŸš€ Actividad: ImplementaciÃ³n Progresiva en 3 Niveles</h3>
            <p><strong>Objetivo:</strong> Construir desde lo simple a lo robusto, entendiendo cada capa.</p>

            <h4>Nivel 1: Publisher MÃ­nimo Viable (15 min)</h4>
            <p><strong>Objetivo:</strong> Que funcione con lo esencial - ver el evento llegar</p>
            
            <div class="dual-lang">
                <div>
                    <h5>Python - Nivel 1 Simple</h5>
                    <div class="code-block code-python">
                        <pre>"""
events.py - Publisher Simple (Nivel 1)
"""
import pika
import json

def publish_user_created_simple(user_data: dict):
    """Lo mÃ­nimo para que funcione"""
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    # Declarar exchange fanout
    channel.exchange_declare(
        exchange='user_events',
        exchange_type='fanout',
        durable=True
    )
    
    # Publicar
    channel.basic_publish(
        exchange='user_events',
        routing_key='',  # Ignorado en fanout
        body=json.dumps(user_data)
    )
    
    connection.close()
    print(f"âœ… Evento publicado: {user_data}")</pre>
                    </div>
                </div>
                <div>
                    <h5>C# - Nivel 1 Simple</h5>
                    <div class="code-block code-csharp">
                        <pre>/*
UserEventPublisher.cs - Publisher Simple (Nivel 1)
*/
using RabbitMQ.Client;
using System.Text;
using System.Text.Json;

public class UserEventPublisher
{
    public void PublishUserCreatedSimple(UserData userData)
    {
        var factory = new ConnectionFactory { HostName = "localhost" };
        using var connection = factory.CreateConnection();
        using var channel = connection.CreateModel();
        
        // Declarar exchange fanout
        channel.ExchangeDeclare(
            "user_events", 
            ExchangeType.Fanout, 
            durable: true
        );
        
        // Publicar
        var json = JsonSerializer.Serialize(userData);
        var body = Encoding.UTF8.GetBytes(json);
        channel.BasicPublish("user_events", "", null, body);
        
        Console.WriteLine($"âœ… Evento publicado: {userData.Email}");
    }
}</pre>
                    </div>
                </div>
            </div>

            <div class="checkpoint">
                <p><strong>Prueba Nivel 1:</strong> Ejecuta el consumer y publisher. Â¿Llega el mensaje? âœ… Siguiente nivel.</p>
            </div>

            <h4>Nivel 2: Agregar Persistencia y Metadata (15 min)</h4>
            <p><strong>Objetivo:</strong> Que los mensajes sobrevivan reinicio de RabbitMQ</p>
            
            <div class="dual-lang">
                <div>
                    <h5>Python - Nivel 2 con Persistencia</h5>
                    <div class="code-block code-python">
                        <pre>"""
events.py - Publisher con Persistencia (Nivel 2)
"""
import pika
import json
from datetime import datetime
import uuid

def publish_user_created_persistent(user_data: dict):
    """Mensajes persisten reinicio de RabbitMQ"""
    
    # Agregar metadata
    message = {
        **user_data,
        "event_type": "UsuarioCreado",
        "event_id": str(uuid.uuid4()),
        "timestamp": datetime.now().isoformat()
    }
    
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost')
    )
    channel = connection.channel()
    
    channel.exchange_declare(
        exchange='user_events',
        exchange_type='fanout',
        durable=True  # Exchange sobrevive reinicio
    )
    
    channel.basic_publish(
        exchange='user_events',
        routing_key='',
        body=json.dumps(message),
        properties=pika.BasicProperties(
            delivery_mode=2,  # â¬…ï¸ NUEVO: Mensaje persistente
            content_type='application/json'
        )
    )
    
    connection.close()
    print(f"âœ… Evento persistente: {message['event_id']}")</pre>
                    </div>
                </div>
                <div>
                    <h5>C# - Nivel 2 con Persistencia</h5>
                    <div class="code-block code-csharp">
                        <pre>/*
UserEventPublisher.cs - Con Persistencia (Nivel 2)
*/
public void PublishUserCreatedPersistent(UserData userData)
{
    var message = new
    {
        userData.Id,
        userData.Email,
        EventType = "UsuarioCreado",
        EventId = Guid.NewGuid().ToString(),
        Timestamp = DateTime.UtcNow.ToString("O")
    };
    
    var factory = new ConnectionFactory { HostName = "localhost" };
    using var connection = factory.CreateConnection();
    using var channel = connection.CreateModel();
    
    channel.ExchangeDeclare("user_events", ExchangeType.Fanout, durable: true);
    
    var json = JsonSerializer.Serialize(message);
    var body = Encoding.UTF8.GetBytes(json);
    
    // â¬‡ï¸ NUEVO: Propiedades de persistencia
    var properties = channel.CreateBasicProperties();
    properties.Persistent = true;
    properties.ContentType = "application/json";
    
    channel.BasicPublish("user_events", "", properties, body);
    Console.WriteLine($"âœ… Evento persistente: {message.EventId}");
}</pre>
                    </div>
                </div>
            </div>

            <div class="checkpoint">
                <p><strong>Prueba Nivel 2:</strong> Publica mensaje, detÃ©n RabbitMQ (<code>docker stop rabbitmq</code>), reinÃ­cialo. Â¿El mensaje sigue ahÃ­? âœ…</p>
            </div>

            <h4>Nivel 3: Confirmaciones y Manejo de Errores (15 min)</h4>
            <p><strong>Objetivo:</strong> Garantizar que RabbitMQ confirmÃ³ la recepciÃ³n</p>
            
            <div class="dual-lang">
                <div>
                    <h5>Python - Nivel 3 Robusto</h5>
                    <div class="code-block code-python">
                        <pre>"""
events.py - Publisher Robusto (Nivel 3)
"""
import pika
import json
from datetime import datetime
import uuid
import time

def publish_user_created(user_data: dict, max_retries: int = 3):
    """Publisher con confirmaciones y reintentos"""
    
    message = {
        **user_data,
        "event_type": "UsuarioCreado",
        "event_id": str(uuid.uuid4()),
        "timestamp": datetime.now().isoformat()
    }
    
    for attempt in range(max_retries):
        try:
            params = pika.ConnectionParameters(
                'localhost',
                credentials=pika.PlainCredentials('user', 'pass')
            )
            
            with pika.BlockingConnection(params) as conn:
                ch = conn.channel()
                
                ch.exchange_declare(
                    exchange='user_events',
                    exchange_type='fanout',
                    durable=True,
                    arguments={'alternate-exchange': 'dead_letters'}
                )
                
                # â¬‡ï¸ NUEVO: Habilitar confirmaciones
                ch.confirm_delivery()
                
                ch.basic_publish(
                    exchange='user_events',
                    routing_key='',
                    body=json.dumps(message),
                    properties=pika.BasicProperties(
                        delivery_mode=2,
                        content_type='application/json'
                    ),
                    mandatory=True  # â¬…ï¸ NUEVO: Falla si no hay queues
                )
                
                print(f"âœ… Evento confirmado: {message['event_id']}")
                return True
                
        except Exception as e:
            print(f"âŒ Intento {attempt + 1}: {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # Backoff exponencial
    
    return False</pre>
                    </div>
                </div>
                <div>
                    <h5>C# - Nivel 3 Robusto</h5>
                    <div class="code-block code-csharp">
                        <pre>/*
UserEventPublisher.cs - Robusto (Nivel 3)
*/
public void PublishUserCreated(UserData userData, int maxRetries = 3)
{
    var message = new
    {
        userData.Id,
        userData.Email,
        EventType = "UsuarioCreado",
        EventId = Guid.NewGuid().ToString(),
        Timestamp = DateTime.UtcNow.ToString("O")
    };

    for (int attempt = 0; attempt < maxRetries; attempt++)
    {
        try
        {
            var factory = new ConnectionFactory { HostName = "localhost" };
            using var connection = factory.CreateConnection();
            using var channel = connection.CreateModel();

            // â¬‡ï¸ NUEVO: Habilitar confirmaciones
            channel.ConfirmSelect();

            channel.ExchangeDeclare(
                "user_events", 
                ExchangeType.Fanout, 
                durable: true,
                arguments: new Dictionary<string, object> 
                { 
                    { "alternate-exchange", "dead_letters" } 
                }
            );

            var json = JsonSerializer.Serialize(message);
            var body = Encoding.UTF8.GetBytes(json);
            
            var properties = channel.CreateBasicProperties();
            properties.Persistent = true;
            properties.ContentType = "application/json";

            channel.BasicPublish("user_events", "", properties, body);
            
            // â¬‡ï¸ NUEVO: Esperar confirmaciÃ³n
            channel.WaitForConfirmsOrDie(TimeSpan.FromSeconds(5));
            
            Console.WriteLine($"âœ… Evento confirmado: {message.EventId}");
            return;
        }
        catch (Exception e)
        {
            Console.WriteLine($"âŒ Intento {attempt + 1}: {e.Message}");
            if (attempt < maxRetries - 1) 
                Thread.Sleep((int)Math.Pow(2, attempt) * 1000);
        }
    }
}</pre>
                    </div>
                </div>
            </div>

            <div class="checkpoint">
                <p><strong>Prueba Nivel 3:</strong> DetÃ©n RabbitMQ antes de publicar. Â¿Los reintentos funcionan? Â¿Hay backoff exponencial? âœ…</p>
            </div>

            <div class="tip">
                <p><strong>Â¿Por quÃ© 3 niveles?</strong> Cada nivel agrega garantÃ­as especÃ­ficas. Para aprender, empieza simple y agrega complejidad cuando entiendas por quÃ© la necesitas.</p>
            </div>
        </div>

        <div class="activity">
            <h3>ğŸ“¥ Consumers: Suscriptores Independientes (30 min)</h3>
            <p><strong>Objetivo:</strong> Implementar 2 consumers simples (email y loyalty); analytics como reto.</p>

            <h4>Consumer Email (Nuevo servicio)</h4>
            <div class="dual-lang">
                <div>
                    <h5>Ejemplo en Python</h5>
                    <div class="code-block code-python">
                        <pre>"""
email_consumer.py - Se suscribe a user_events
"""
import pika
import json

def process_user_created_email(ch, method, props, body):
    message = json.loads(body)
    if message.get('event_type') == 'UsuarioCreado':
        print(f"ğŸ“§ Enviando email a {message['email']}")
        # LÃ³gica email simple (print por ahora)
        ch.basic_ack(delivery_tag=method.delivery_tag)
    else:
        ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)

def start_email_consumer():
    params = pika.ConnectionParameters(
        'localhost', 
        credentials=pika.PlainCredentials('user', 'pass')
    )
    conn = pika.BlockingConnection(params)
    ch = conn.channel()
    ch.exchange_declare(
        exchange='user_events', 
        exchange_type='fanout', 
        durable=True
    )
    
    result = ch.queue_declare(queue='', exclusive=True)
    queue_name = result.method.queue
    
    ch.queue_bind(exchange='user_events', queue=queue_name)
    
    ch.basic_qos(prefetch_count=1)
    ch.basic_consume(
        queue=queue_name, 
        on_message_callback=process_user_created_email
    )
    print("ğŸ§ Email consumer esperando...")
    ch.start_consuming()

if __name__ == "__main__":
    start_email_consumer()</pre>
                    </div>
                </div>
                <div>
                    <h5>Ejemplo en C#</h5>
                    <div class="code-block code-csharp">
                        <pre>/*
EmailConsumer.cs - Se suscribe a user_events
*/
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;
using System.Text.Json;

public class EmailConsumer
{
    public void Start()
    {
        var factory = new ConnectionFactory { HostName = "localhost" };
        using var connection = factory.CreateConnection();
        using var channel = connection.CreateModel();

        channel.ExchangeDeclare(
            "user_events", 
            ExchangeType.Fanout, 
            durable: true
        );

        var queueName = channel.QueueDeclare().QueueName;
        channel.QueueBind(
            queue: queueName, 
            exchange: "user_events", 
            routingKey: ""
        );

        Console.WriteLine(" [*] Waiting for events. To exit press CTRL+C");

        var consumer = new EventingBasicConsumer(channel);
        consumer.Received += (model, ea) =>
        {
            var body = ea.Body.ToArray();
            var json = Encoding.UTF8.GetString(body);
            var message = JsonSerializer.Deserialize<JsonElement>(json);
            
            if (message.GetProperty("event_type").GetString() == "UsuarioCreado")
            {
                var email = message.GetProperty("email").GetString();
                Console.WriteLine($"ğŸ“§ Enviando email a {email}");
            }
            channel.BasicAck(ea.DeliveryTag, false);
        };
        
        channel.BasicConsume(
            queue: queueName, 
            autoAck: false, 
            consumer: consumer
        );

        Console.ReadLine();
    }
}</pre>
                    </div>
                </div>
            </div>

            <h4>Consumer Loyalty (Similar)</h4>
            <div class="dual-lang">
                <div>
                    <h5>Ejemplo en Python</h5>
                    <div class="code-block code-python">
                        <pre># loyalty_consumer.py
# Copia estructura de email, cambia:
def process_user_created_loyalty(ch, method, props, body):
    message = json.loads(body)
    if message.get('event_type') == 'UsuarioCreado':
        print(f"ğŸ Activando lealtad para {message.get('user_id')}")
        ch.basic_ack(delivery_tag=method.delivery_tag)</pre>
                    </div>
                </div>
                <div>
                    <h5>Ejemplo en C#</h5>
                    <div class="code-block code-csharp">
                        <pre>// Similar estructura, cambia en Received:
if (message.GetProperty("event_type").GetString() == "UsuarioCreado")
{
    var userId = message.GetProperty("user_id").GetString();
    Console.WriteLine($"ğŸ Activando lealtad para {userId}");
    channel.BasicAck(ea.DeliveryTag, false);
}</pre>
                    </div>
                </div>
            </div>

            <p><strong>Ejecuta:</strong> <code>python email_consumer.py &</code> y <code>python loyalty_consumer.py</code> (o corre las apps C#).</p>
        </div>

        <div class="tip">
            <h4>ğŸš€ Reto: Analytics Consumer y DLQ</h4>
            <p>Implementa consumer que loggea; configura dead_letters exchange para eventos fallidos (reintentos >3).</p>
        </div>

        <div class="ai-prompt">
            <h4>ğŸ¤– Prompt para IA: RevisiÃ³n Pub/Sub</h4>
            <pre>Revisa mi impl. de Pub/Sub en RabbitMQ:

CÃ³digo: [pegar arriba]

Contexto:
- Eventos UsuarioCreado broadcast a 3 servicios
- Volumen 800/dÃ­a â†’ 2400/dÃ­a
- <1% perdidos
- Equipo pequeÃ±o

EvalÃºa:
1. Â¿Garantiza entrega a todos suscriptores?
2. Â¿QuÃ© si RabbitMQ reinicia con eventos pendientes?
3. Â¿Maneja duplicados en reconexiones?
4. Â¿Escala volumen?
5. Problemas operacionales?
6. Configs faltantes?

Por problema: Por quÃ© importante, manifestaciÃ³n prod, cÃ³digo fix.</pre>
        </div>

        <div class="checkpoint">
            <h3>âœ… Checkpoint de Fase 2</h3>
            <ul>
                <li>RabbitMQ con Fanout configurado</li>
                <li>Publisher usa exchange durable y confirmaciones</li>
                <li>Consumers bind independientes, ACK manual</li>
                <li>IntegrÃ© con mi cÃ³digo de Semana 2</li>
                <li>Explico configs (fanout=desacoplamiento, bindings=escalabilidad)</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸ§ª">Fase 3: ValidaciÃ³n y Pruebas de Desacoplamiento (30 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Demuestra que Pub/Sub resuelve acoplamiento del Fase 0, con E2E y fallos.</p>

        <div class="activity">
            <h3>ğŸ”¥ Pruebas de Eventos Desacoplados</h3>
            <p><strong>Objetivo:</strong> Verificar flujo E2E y resiliencia.</p>

            <div class="scenario-box">
                <h4>âš¡ Diagrama: Flujo de ValidaciÃ³n con Manejo de Errores</h4>
                <div class="mermaid">
%%{ init: { "flowchart": { "htmlLabels": true } } }%%
graph TB
    A[Publisher: Evento UsuarioCreado] -->|publish| B[RabbitMQ Exchange]
    B -->|fanout| C[Queue Email]
    B -->|fanout| D[Queue Loyalty]
    C -->|consume| E[Email Service]
    D -->|consume| F[Loyalty Service]
    
    E -->|ACK âœ…| C
    F -->|NACK + requeue âš ï¸| D
    
    D -->|retry 1| F
    D -->|retry 2| F
    D -->|retry 3 failed| G[Dead Letter Queue]
    
    style G fill:#f9d0d0
    style E fill:#d0f9d0
    style F fill:#f9f0d0
                </div>
                <pre class="diagram">
PRUEBA 1: BROADCAST DURANTE REINICIO
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” publish     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” restart    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Registro â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â†’   â”‚ RabbitMQ    â”‚ â”€â”€â”€â”€â”€â”€â†’    â”‚ RabbitMQ    â”‚
â”‚1 evento â”‚             â”‚ (fanout)    â”‚            â”‚ (recupera)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚                             â”‚
                                  â–¼                             â–¼
                           [Evento en todas         [3 queues intactas]
                            queues]                        â”‚
                                  â”‚                        â–¼
                                  â”‚                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                  â”‚                 â”‚Email    â”‚ â”‚Loyalty  â”‚ â”‚Analyticsâ”‚
                                  â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ âœ…
VALIDACIÃ“N: Â¿Llegan 3 reacciones? 

PRUEBA 2: RESILIENCIA SUSCRIPTOR (Fallo + DLQ)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” publish     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” consume    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Registro â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â†’   â”‚ RabbitMQ    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚Email    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ (crash)â”‚ âŒ
                                  â”‚                             â”‚
                                  â–¼                             â–¼
                           [Evento en queue]            [Sin ACK = requeue â†’ DLQ si >3]
                                  â”‚                             â”‚
                                  â–¼                             â–¼
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚ RabbitMQ    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â†’      â”‚Email    â”‚
                           â”‚ (requeue)   â”‚                â”‚(restart)â”‚ âœ…
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
VALIDACIÃ“N: Â¿Otros consumers no afectados? Â¿DLQ captura fallos?

RESULTADO: DESACOPLAMIENTO VALIDADO
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Broadcast garantizado   âœ… Suscriptores independientes
âœ… Recovery automÃ¡tico     âœ… Sin impacto en publisher
âœ… Escalabilidad probada   âœ… ROI: Latencia â†“95%
                </pre>
            </div>

            <h4>Prueba 1: E2E Broadcast (10 min)</h4>
            <ol>
                <li>Inicia consumers: <code>python email_consumer.py &</code> y <code>python loyalty_consumer.py</code> (o apps C#)</li>
                <li>Usa Postman/curl para POST /users: <code>curl -X POST http://localhost:8000/users -H "Content-Type: application/json" -d '{"email": "test@eco.com"}'</code></li>
                <li><strong>Esperado:</strong> Logs en consumers: "ğŸ“§ Enviando email" y "ğŸ Activando lealtad"</li>
            </ol>

            <h4>Prueba 2: Fallo en Suscriptor + DLQ (10 min)</h4>
            <ol>
                <li>Inicia consumers</li>
                <li>Publica evento con curl</li>
                <li>Mata email_consumer (Ctrl+C) ANTES de ACK (agrega <code>sleep(10)</code> en process para simular lento)</li>
                <li>Reinicia email_consumer</li>
                <li><strong>Esperado:</strong> Loyalty procesa; Email reprocesa. Checa Management UI para DLQ si >3 fallos</li>
            </ol>

            <h4>Prueba 3: Agregar Consumer sin Tocar Publisher (10 min)</h4>
            <div class="activity">
                <p><strong>Objetivo:</strong> Demostrar desacoplamiento total.</p>
                <ol>
                    <li>Sin detener nada, crea <code>analytics_consumer.py</code> (copia email_consumer, cambia el mensaje)</li>
                    <li>EjecÃºtalo: <code>python analytics_consumer.py</code></li>
                    <li>Publica un nuevo usuario</li>
                    <li><strong>Esperado:</strong> 3 consumers reaccionan (email, loyalty, analytics) sin haber modificado el publisher</li>
                </ol>
                <div class="checkpoint">
                    <p><strong>Â¡Esto es desacoplamiento!</strong> El publisher no sabe cuÃ¡ntos ni quiÃ©nes consumen sus eventos.</p>
                </div>
            </div>
        </div>

        <div class="reflection">
            <h3>ğŸ“Š MÃ©tricas de ValidaciÃ³n</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>MÃ©trica</th>
                        <th>HTTP Acoplado</th>
                        <th>Con Pub/Sub</th>
                        <th>Mejora</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Latencia por evento</td>
                        <td>600ms (3 llamadas)</td>
                        <td>50ms (1 publish)</td>
                        <td>92% mÃ¡s rÃ¡pido</td>
                    </tr>
                    <tr>
                        <td>Disponibilidad</td>
                        <td>95% (1 fallo afecta todos)</td>
                        <td>99.9% (independiente)</td>
                        <td>20x mejor</td>
                    </tr>
                    <tr>
                        <td>Eventos perdidos</td>
                        <td>5% por sobrecarga</td>
                        <td><0.1%</td>
                        <td>50x mÃ¡s confiable</td>
                    </tr>
                    <tr>
                        <td>Esfuerzo agregar suscriptor</td>
                        <td>Modificar publisher</td>
                        <td>Solo bind queue</td>
                        <td>10x mÃ¡s simple</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>ğŸ¯ ROI Demostrado</h3>
            <ul>
                <li><strong>Antes:</strong> $2,000/dÃ­a en fallos engagement</li>
                <li><strong>DespuÃ©s:</strong> $0 perdidos, suscriptores escalan gratis</li>
                <li><strong>Costo impl.:</strong> ~30 horas</li>
                <li><strong>Payback:</strong> Primera semana de uso</li>
            </ul>
        </div>

        <div class="checkpoint">
            <h3>âœ… Checkpoint Final</h3>
            <ul>
                <li>Pruebas de caos pasaron</li>
                <li>ROI cuantificado vs anterior</li>
                <li>DemostrÃ© desacoplamiento agregando consumer</li>
                <li>Entiendo nuevos problemas (e.g., event storming) y monitoreo</li>
                <li>Plan para Hito 1: Integrar en sistema distribuido bÃ¡sico</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸš€">ReflexiÃ³n Final: El Verdadero Aprendizaje</h2>
        
        <div class="reflection">
            <h3>ğŸ¤” Preguntas Profundas</h3>
            <ol>
                <li><strong>EvoluciÃ³n:</strong> Â¿Por quÃ© paso a paso vs directo a eventos?</li>
                <li><strong>Complejidad:</strong> Â¿CuÃ¡ndo Pub/Sub vale vs costo?</li>
                <li><strong>Patrones:</strong> Â¿Otros problemas en trabajo con este journey?</li>
                <li><strong>Arquitectura:</strong> Â¿Cambios si startup vs enterprise?</li>
            </ol>
        </div>

        <div class="ai-prompt">
            <h4>ğŸ¤– Prompt Final: SÃ­ntesis</h4>
            <pre>Sintetiza mi aprendizaje en decisiones arquitectÃ³nicas:

Journey:
1. EmpecÃ©: [HTTP acoplado]
2. Problemas: [5% fallos, $X/mes]
3. Alternativas: [punto-a-punto, fanout]
4. ElegÃ­: [Pub/Sub] por [razones]
5. Impl. con: [garantÃ­as]
6. ValidÃ©: [desacoplamiento]

Reflexiones:
1. Principios generales?
2. Balance complejidad-beneficio?
3. Preguntas pre-adopciÃ³n?
4. ComunicaciÃ³n a stakeholders?

Framework reusable para futuras decisiones.</pre>
        </div>
        
        <div class="decision-matrix">
            <h4>ğŸ“‹ Framework Mental (Ejemplo):</h4>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Principio</th>
                        <th>Pregunta GuÃ­a</th>
                        <th>Ejemplo EcoMarket</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Cuantificar Acoplamiento</strong></td>
                        <td>Â¿$X/mes por dependencias?</td>
                        <td>$2k/dÃ­a fallos â†’ $60k/mes</td>
                    </tr>
                    <tr>
                        <td><strong>Evaluar Desacoplamiento</strong></td>
                        <td>Â¿Escala N suscriptores?</td>
                        <td>Fanout OK now, Topic for filters</td>
                    </tr>
                    <tr>
                        <td><strong>Validar ROI</strong></td>
                        <td>Â¿Payback <1 mes?</td>
                        <td>SÃ­, latencia â†“92% paga impl.</td>
                    </tr>
                    <tr>
                        <td><strong>Incremental</strong></td>
                        <td>Â¿Probar PoC?</td>
                        <td>EmpecÃ© con queues, evolucionÃ© a fanout</td>
                    </tr>
                    <tr>
                        <td><strong>Medir Impacto</strong></td>
                        <td>Â¿Cumple promesas?</td>
                        <td>95% â†’ 99.9% disponibilidad empÃ­rica</td>
                    </tr>
                </tbody>
            </table>
            <p><em>Transferible a: Notificaciones, audits, scaling DB, etc.</em></p>
        </div>

        <div class="tip">
            <h3>ğŸ“ Valor Real</h3>
            <p>Aprendiste:</p>
            <ul>
                <li><strong>MetodologÃ­a:</strong> Evolucionar arquitecturas incrementalmente</li>
                <li><strong>JustificaciÃ³n:</strong> Cuantificar desacoplamiento con ROI</li>
                <li><strong>Impl.:</strong> Pub/Sub con garantÃ­as de producciÃ³n</li>
                <li><strong>ValidaciÃ³n:</strong> Probar independencia con casos reales</li>
            </ul>
            <p><strong>Para Hito 1:</strong> Integra este Pub/Sub en tu sistema distribuido bÃ¡sico.</p>
        </div>
    </div>

    <p style="text-align: center; margin-top: 30px;">
        ğŸ‰ Â¡Felicitaciones! Ahora dominas Pub/Sub: No solo cÃ³mo, sino cuÃ¡ndo y por quÃ© en sistemas distribuidos.
    </p>
</body>
</html>