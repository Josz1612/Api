<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoMarket: El Journey hacia Colas de Mensajes</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .phase {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .phase h2 {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        .phase h2::before {
            content: attr(data-icon);
            font-size: 1.5em;
            margin-right: 10px;
        }
        .activity {
            background: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .checkpoint {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin: 5px 0;
        }
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .tip {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .reflection {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .evolution-step {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
        }
        .evolution-step::after {
            content: "â†“";
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #3498db;
        }
        .evolution-step:last-child::after {
            display: none;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            background: white;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .comparison-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .decision-matrix {
            background: #fff;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .ai-prompt {
            background: #e8f5e8;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
        }
        .progress-item {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: #e9ecef;
            margin: 0 5px;
            border-radius: 5px;
        }
        .progress-item.active {
            background: #3498db;
            color: white;
        }
        .scenario-box {
            background: #f0f8ff;
            border: 1px solid #3498db;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .diagram {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            white-space: pre;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>EcoMarket: El Journey hacia Colas de Mensajes</h1>
    <p>De problemas simples a soluciones evolutivas: Por quÃ© y cuÃ¡ndo necesitas RabbitMQ</p>

    <div class="progress-bar">
        <div class="progress-item active">ğŸ¯ Fase 0: El Problema Real</div>
        <div class="progress-item">ğŸ”„ Fase 1: EvoluciÃ³n de Soluciones</div>
        <div class="progress-item">ğŸ’» Fase 2: Implementando RabbitMQ</div>
        <div class="progress-item">ğŸ§ª Fase 3: ValidaciÃ³n</div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸ¯">Fase 0: El Problema Real que Justifica la Complejidad (30 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Entender EXACTAMENTE por quÃ© las soluciones simples fallan antes de saltar a RabbitMQ. Al final, podrÃ¡s justificar cada gramo de complejidad adicional que introduces.</p>

        <h3>ğŸª Escenario: EcoMarket en Crisis</h3>
        <p>Tu implementaciÃ³n HTTP directa funciona bien... hasta que no. Han llegado reportes preocupantes:</p>

        <div class="scenario-box">
            <h4>ğŸ“Š Datos Reales del Sistema Actual:</h4>
            <ul>
                <li><strong>Volumen:</strong> 50 ventas por hora en horarios pico</li>
                <li><strong>Latencia de red:</strong> 200ms promedio entre sucursal y central</li>
                <li><strong>Fallos de red:</strong> 2-3% de las notificaciones HTTP fallan</li>
                <li><strong>Tiempo de recuperaciÃ³n:</strong> Cuando central se cae, tarda 5-10 minutos en volver</li>
                <li><strong>Costo de venta perdida:</strong> $180 promedio por venta</li>
            </ul>
        </div>

        <div class="scenario-box">
            <h4>ğŸ“ˆ Diagrama: El Problema Actual que Justifica la InversiÃ³n</h4>
            <pre style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
SITUACIÃ“N ACTUAL: HTTP Directo
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    HTTP POST     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sucursal    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ Central     â”‚
â”‚ (vende)     â”‚ â† 3-5 segundos â†’ â”‚ (actualiza) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                                   âŒ
      â”‚ Si Central estÃ¡ caÃ­do:           â”‚
      â”œâ”€â”€Xâ”€â”€ Request timeout            â”‚
      â”œâ”€â”€Xâ”€â”€ Cliente se va frustrado    â”‚
      â””â”€â”€Xâ”€â”€ Venta perdida: $180        â”‚

COSTO REAL: 2% fallos Ã— 400 ventas/dÃ­a Ã— $180 = $1,440 perdidos/dÃ­a
ESCALAMIENTO: 10 sucursales = $14,400 perdidos/dÃ­a en fallos
            </pre>
        </div>

        <div class="warning">
            <h3>âš ï¸ Los SÃ­ntomas del Dolor</h3>
            <p><strong>Reporte del Gerente:</strong> "Ayer perdimos 8 ventas porque el sistema se quedÃ³ 'pensando' y los clientes se fueron frustrados."</p>
            <p><strong>Reporte TÃ©cnico:</strong> Durante la caÃ­da de 8 minutos del servidor central, las sucursales no pudieron procesar ventas porque esperaban confirmaciÃ³n del inventario.</p>
            <p><strong>Impacto:</strong> 8 ventas Ã— $180 = $1,440 perdidos en una sola hora.</p>
        </div>

        <div class="activity">
            <h3>ğŸ§® Actividad: Calculando el Costo de No Actuar</h3>
            <p>Antes de buscar soluciones, cuantifica el problema:</p>
            <ol>
                <li><strong>Con tu equipo, calculen:</strong> Si el sistema actual falla 2% de las veces y procesan 400 ventas/dÃ­a, Â¿cuÃ¡nto dinero pierden al mes?</li>
                <li><strong>Proyecten crecimiento:</strong> Si EcoMarket crece a 10 sucursales, Â¿cÃ³mo escala el problema?</li>
                <li><strong>Definan umbral de dolor:</strong> Â¿A partir de quÃ© pÃ©rdida mensual vale la pena invertir tiempo en una soluciÃ³n mÃ¡s compleja?</li>
            </ol>
            <p><strong>Meta:</strong> Tener un nÃºmero concreto que justifique la inversiÃ³n en mejoras.</p>
        </div>

        <div class="ai-prompt">
            <h4>ğŸ¤– Prompt para IA: AnÃ¡lisis de Impacto</h4>
            <pre>AyÃºdame a analizar el impacto de fallos en mi sistema de ventas:

Contexto:
- Ventas por dÃ­a: 400
- Valor promedio por venta: $180
- Tasa de fallos actual: 2%
- Tiempo promedio de caÃ­da: 8 minutos
- Frecuencia de caÃ­das: 2 veces por semana

Preguntas:
1. Â¿CuÃ¡l es el costo mensual de los fallos actuales?
2. Si crecemos 5x en volumen, Â¿cÃ³mo escala el problema?
3. Â¿A partir de quÃ© punto un fallo de sistema se vuelve crÃ­tico para el negocio?
4. Â¿QuÃ© otros costos ocultos podrÃ­a estar pasando por alto?

Dame nÃºmeros especÃ­ficos y escenarios concretos.</pre>
        </div>

        <div class="checkpoint">
            <h3>âœ… Checkpoint de Fase 0 - RÃºbrica de EvaluaciÃ³n</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Criterio</th>
                        <th>Â¿Cumple?</th>
                        <th>Evidencia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>CalculÃ© el costo real mensual de los fallos actuales</td>
                        <td>â–¡ SÃ­ / â–¡ No</td>
                        <td>Tengo el nÃºmero: $______ /mes</td>
                    </tr>
                    <tr>
                        <td>IdentifiquÃ© el umbral donde justifica invertir en mejoras</td>
                        <td>â–¡ SÃ­ / â–¡ No</td>
                        <td>Si pÃ©rdidas > $______, invierto en RabbitMQ</td>
                    </tr>
                    <tr>
                        <td>Entiendo por quÃ© "funciona en mi mÃ¡quina" no es suficiente</td>
                        <td>â–¡ SÃ­ / â–¡ No</td>
                        <td>Puedo explicar 2 diferencias prod vs dev</td>
                    </tr>
                    <tr>
                        <td>ComparÃ© mi caso con experiencia laboral previa</td>
                        <td>â–¡ SÃ­ / â–¡ No</td>
                        <td>IdentifiquÃ© problema similar en mi trabajo</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸ”„">Fase 1: La EvoluciÃ³n Natural de Soluciones (45 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Explorar cada soluciÃ³n incremental y entender EXACTAMENTE dÃ³nde falla antes de pasar a la siguiente. Este es el journey que siguen todos los sistemas reales.</p>

        <h3>ğŸš€ El Evolution Journey</h3>
        <p>No saltas directo a RabbitMQ. Evolucionas paso a paso cuando cada soluciÃ³n muestra sus lÃ­mites:</p>

        <div class="scenario-box">
            <h4>ğŸ”„ Diagrama: Evolution Journey - Cada Paso y DÃ³nde Falla</h4>
            <pre style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
PASO 1: HTTP DIRECTO
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€HTTP POSTâ”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Sucursal â”‚               â”‚Central  â”‚ âœ… Funciona: Todo perfecto
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ âŒ Falla: Red lenta/central caÃ­do
    â†“ Problema: 2% fallos = $1,440/dÃ­a perdidos

PASO 2: HTTP + RETRY SIMPLE  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€â”¬â”€retry 1â”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Sucursal â”‚   â”œâ”€retry 2â”€â†’ â”‚Central  â”‚ âœ… Funciona: Fallos &lt;30s
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€retry 3â”€â†’ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ âŒ Falla: Central caÃ­do &gt;1min
    â†“ Problema: Cliente espera 9+ segundos

PASO 3: HTTP + BACKOFF EXPONENCIAL
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€â”¬â”€1sâ”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Sucursal â”‚   â”œâ”€2sâ”€â†’ â”‚Central  â”‚ âœ… Funciona: Fallos &lt;5min
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”œâ”€4sâ”€â†’ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ âŒ Falla: 10 sucursales simultÃ¡neas
              â””â”€8sâ”€â†’              sobrecargan al central recuperÃ¡ndose
    â†“ Problema: Thundering herd + cliente espera 15+ segundos

PASO 4: COLA EN MEMORIA (Redis)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€pushâ”€â†’ [Redis] â”€â”€popâ”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Sucursal â”‚          Queue          â”‚Central  â”‚ âœ… Funciona: Fallos de horas
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ âŒ Falla: Redis restart = pÃ©rdida
    â†“ Problema: 100ms venta + riesgo pÃ©rdida en restart

PASO 5: MESSAGE BROKER (RabbitMQ)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”€â”€publishâ”€â†’ [ğŸ° Durable] â”€â”€consumeâ”€â†’ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Sucursal â”‚             Queue + ACK              â”‚Central  â”‚ âœ… Funciona: GarantÃ­as totales
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ âŒ Nuevo costo: Infraestructura
    â†“ SoluciÃ³n: 50ms venta + 0% pÃ©rdida + escalabilidad

DECISIÃ“N: Â¿Vale la pena la complejidad por las garantÃ­as?
          Si pÃ©rdidas &gt; costo operacional â†’ SÃ
            </pre>
        </div>

        <div class="evolution-step">
            <h4>Paso 1: HTTP Directo (Tu implementaciÃ³n actual)</h4>
            <p><strong>CÃ³digo:</strong> `await httpx.post(central_url, json=data)`</p>
            <p><strong>Funciona cuando:</strong> Todo estÃ¡ perfecto</p>
            <p><strong>Falla cuando:</strong> Red lenta, central caÃ­do, timeout</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 2: HTTP con Reintentos Simples</h4>
            <p><strong>CÃ³digo:</strong> Loop de 3 intentos con sleep(1)</p>
            <p><strong>Funciona cuando:</strong> Fallos transitorios</p>
            <p><strong>Falla cuando:</strong> Central caÃ­do por mÃ¡s tiempo que tus reintentos</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 3: HTTP con Backoff Exponencial</h4>
            <p><strong>CÃ³digo:</strong> sleep(2^attempt) entre reintentos</p>
            <p><strong>Funciona cuando:</strong> Fallos de algunos minutos</p>
            <p><strong>Falla cuando:</strong> Central caÃ­do por horas, muchas sucursales reintentando</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 4: Cola en Memoria (Redis/Lista)</h4>
            <p><strong>CÃ³digo:</strong> Push a Redis list, worker que procesa</p>
            <p><strong>Funciona cuando:</strong> Fallos de hasta varias horas</p>
            <p><strong>Falla cuando:</strong> El servidor Redis se reinicia, complejidad de mÃºltiples consumers</p>
        </div>

        <div class="evolution-step">
            <h4>Paso 5: Message Broker (RabbitMQ)</h4>
            <p><strong>CÃ³digo:</strong> Publish a queue durable, consumer con ACK</p>
            <p><strong>Funciona cuando:</strong> Necesitas garantÃ­as de entrega y escalabilidad</p>
            <p><strong>Nuevo costo:</strong> Infraestructura adicional, complejidad operacional</p>
        </div>

        <div class="activity">
            <h3>ğŸ§ª Actividad: Implementando y Rompiendo Cada Paso</h3>
            <p>Vamos a implementar y "romper" cada soluciÃ³n para entender dÃ³nde falla:</p>

            <h4>Paso 2A: Implementa Reintentos Simples (15 min)</h4>
            <div class="code-block">
                <pre>async def notify_with_simple_retry(data: dict, max_attempts: int = 3):
    for attempt in range(max_attempts):
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.post(CENTRAL_URL, json=data)
                if response.status_code == 200:
                    logger.info(f"âœ… Ã‰xito en intento {attempt + 1}")
                    return True
                else:
                    logger.warning(f"âš ï¸ HTTP {response.status_code} en intento {attempt + 1}")
        except Exception as e:
            logger.error(f"âŒ Intento {attempt + 1} fallÃ³: {e}")
            if attempt < max_attempts - 1:
                await asyncio.sleep(1)  # Espera fija
    
    logger.error("âŒ FallÃ³ despuÃ©s de todos los intentos simples")
    return False</pre>
            </div>

            <p><strong>Prueba de ruptura:</strong> Apaga el servidor central por 5 minutos. Â¿QuÃ© pasa?</p>
            
            <div class="tip">
                <h4>ğŸ¤” Â¿QuÃ© pasarÃ­a si...?</h4>
                <p><strong>Escenario:</strong> Si tu aplicaciÃ³n se ejecuta en un centro comercial con WiFi intermitente que se corta cada 30 segundos por 10 segundos:</p>
                <ul>
                    <li>Retry simple: 3 intentos Ã— 1s = 3s total â†’ âŒ Falla porque corte dura 10s</li>
                    <li>Cliente espera 3s y ve error â†’ Experiencia frustrante</li>
                    <li>Ventas perdidas en horas pico del centro comercial</li>
                </ul>
            </div>

            <h4>Paso 2B: Mejora con Backoff Exponencial (10 min)</h4>
            <div class="code-block">
                <pre>async def notify_with_backoff(data: dict, max_attempts: int = 5):
    for attempt in range(max_attempts):
        try:
            # ... mismo cÃ³digo de httpx ...
            return True
        except Exception as e:
            logger.error(f"âŒ Intento {attempt + 1} fallÃ³: {e}")
            if attempt < max_attempts - 1:
                wait_time = 2 ** attempt  # 1, 2, 4, 8, 16 segundos
                logger.info(f"â° Esperando {wait_time}s antes del siguiente intento")
                await asyncio.sleep(wait_time)
    
    return False</pre>
            </div>

            <p><strong>Prueba de ruptura:</strong> Â¿QuÃ© pasa si 10 sucursales reintentan simultÃ¡neamente cuando el central vuelve?</p>
            
            <div class="tip">
                <h4>ğŸ¤” Â¿QuÃ© pasarÃ­a si...?</h4>
                <p><strong>Escenario "Thundering Herd":</strong> Central se cae 5 minutos, 10 sucursales esperando:</p>
                <ul>
                    <li>Todas han acumulado reintentos y esperan 16-32 segundos</li>
                    <li>Central vuelve â†’ las 10 sucursales atacan simultÃ¡neamente</li>
                    <li>Central se sobrecarga â†’ vuelve a caerse</li>
                    <li>Ciclo infinito de caÃ­da-recovery-sobrecarga</li>
                </ul>
            </div>
        </div>

        <div class="decision-matrix">
            <h3>ğŸ“Š Matriz de DecisiÃ³n: Â¿CuÃ¡ndo usar quÃ©?</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>SoluciÃ³n</th>
                        <th>Complejidad</th>
                        <th>Funciona hasta</th>
                        <th>Falla cuando</th>
                        <th>Costo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>HTTP Directo</strong></td>
                        <td>Muy Baja</td>
                        <td>10 ventas/hora, red perfecta</td>
                        <td>Cualquier fallo de red</td>
                        <td>Muy Bajo</td>
                    </tr>
                    <tr>
                        <td><strong>Retry Simple</strong></td>
                        <td>Baja</td>
                        <td>50 ventas/hora, fallos &lt;30s</td>
                        <td>Central caÃ­do &gt;1 min</td>
                        <td>Bajo</td>
                    </tr>
                    <tr>
                        <td><strong>Backoff Exponencial</strong></td>
                        <td>Baja-Media</td>
                        <td>100 ventas/hora, fallos &lt;5 min</td>
                        <td>Central caÃ­do &gt;15 min, mÃºltiples sucursales</td>
                        <td>Bajo</td>
                    </tr>
                    <tr>
                        <td><strong>Cola en Memoria</strong></td>
                        <td>Media</td>
                        <td>500 ventas/hora, fallos &lt;2 horas</td>
                        <td>Servidor de cola se reinicia</td>
                        <td>Medio</td>
                    </tr>
                    <tr>
                        <td><strong>Message Broker</strong></td>
                        <td>Alta</td>
                        <td>Miles/hora, fallos de horas/dÃ­as</td>
                        <td>ConfiguraciÃ³n incorrecta</td>
                        <td>Alto</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="ai-prompt">
            <h4>ğŸ¤– Prompt para IA: AnÃ¡lisis de Alternativas</h4>
            <pre>Analiza estas alternativas para mi sistema de notificaciones:

Mi contexto especÃ­fico:
- Volumen actual: 400 ventas/dÃ­a (50 en hora pico)
- Crecimiento esperado: 5x en prÃ³ximos 6 meses
- Tolerancia a fallos: mÃ¡ximo 1% de notificaciones perdidas
- Equipo tÃ©cnico: 2 desarrolladores, sin DevOps dedicado
- Presupuesto: preferencia por soluciones simples

Alternativas evaluando:
1. HTTP con retry + backoff exponencial
2. Redis como cola + worker Python
3. RabbitMQ con durable queues
4. Azure Service Bus (cloud)

Para cada alternativa, evalÃºa:
- Â¿Cumple mis requerimientos actuales?
- Â¿Escala para mi crecimiento proyectado?
- Â¿QuÃ© esfuerzo de implementaciÃ³n requiere?
- Â¿QuÃ© nuevos problemas operacionales introduce?
- Â¿En quÃ© punto me forzarÃ­a a migrar a algo mÃ¡s complejo?

Recomienda cuÃ¡l implementar AHORA y cuÃ¡l serÃ­a mi upgrade path.</pre>
        </div>

        <div class="reflection">
            <h3>ğŸ¤” Momento de DecisiÃ³n CrÃ­tica</h3>
            <p><strong>Pregunta para tu equipo:</strong> "BasÃ¡ndose en nuestros nÃºmeros reales, Â¿en quÃ© punto del journey estamos FORZADOS a dar el siguiente paso?"</p>
            <p><strong>Datos para considerar:</strong></p>
            <ul>
                <li>Costo actual de fallos: $X/mes</li>
                <li>Tiempo de implementaciÃ³n de cada soluciÃ³n</li>
                <li>Complejidad operacional que podemos manejar</li>
                <li>Horizonte de crecimiento realista</li>
            </ul>
        </div>

        <div class="checkpoint">
            <h3>âœ… Checkpoint de Fase 1</h3>
            <ul>
                <li>ImplementÃ© y probÃ© al menos 2 alternativas simples</li>
                <li>Entiendo exactamente dÃ³nde falla cada soluciÃ³n</li>
                <li>Tengo una justificaciÃ³n cuantitativa para el siguiente paso</li>
                <li>Puedo explicar por quÃ© RabbitMQ no es overkill para mi caso</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸ’»">Fase 2: Implementando RabbitMQ con PropÃ³sito (60 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Ahora que entiendes POR QUÃ‰ necesitas un message broker, implementa RabbitMQ sabiendo exactamente quÃ© problema especÃ­fico estÃ¡s resolviendo.</p>

        <div class="tip">
            <h3>ğŸ’¡ Contexto de la ImplementaciÃ³n</h3>
            <p>No estÃ¡s implementando RabbitMQ porque "es cool" o "es enterprise". Lo implementas porque:</p>
            <ul>
                <li>Necesitas garantÃ­as de entrega que HTTP no puede ofrecer</li>
                <li>Tu sistema debe ser resiliente a caÃ­das de horas, no minutos</li>
                <li>Vas a escalar a mÃºltiples sucursales que necesitan procesamiento desacoplado</li>
                <li>El costo de perder notificaciones supera el costo de la complejidad adicional</li>
            </ul>
        </div>

        <h3>ğŸ—ï¸ Arquitectura con PropÃ³sito</h3>

        <div class="scenario-box">
            <h4>ğŸ¯ Diagrama: Arquitectura Final - Cada Componente Justificado</h4>
            <pre style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
ARQUITECTURA COMPLETA CON GARANTÃAS DE PRODUCCIÃ“N

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SUCURSAL API  â”‚                 â”‚        RABBITMQ BROKER      â”‚
â”‚                 â”‚                 â”‚                             â”‚
â”‚ 1. Venta local  â”‚ â”€â”€publishâ”€â”€â”€â”€â†’  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚    (50ms)       â”‚   (durable +    â”‚  â”‚  sale_notifications â”‚    â”‚
â”‚                 â”‚    confirms)    â”‚  â”‚                     â”‚    â”‚
â”‚ 2. Respuesta    â”‚                 â”‚  â”‚ â€¢ Queue durable     â”‚    â”‚
â”‚    inmediata    â”‚                 â”‚  â”‚ â€¢ Messages persist  â”‚    â”‚ â”€â”€consumeâ”€â”€â†’
â”‚                 â”‚                 â”‚  â”‚ â€¢ ACK requerido     â”‚    â”‚   (prefetch=1)
â”‚ 3. Background   â”‚                 â”‚  â”‚ â€¢ TTL 24h          â”‚    â”‚
â”‚    task notificaâ”‚                 â”‚  â”‚ â€¢ Dead letter queue â”‚    â”‚
â”‚                 â”‚                 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                                              â”‚
         â”‚ GarantÃ­a: Venta NUNCA falla                                  â”‚
         â”‚ por problemas de red                                         â”‚
         â”‚                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                                          â”‚    CENTRAL API          â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DESACOPLAMIENTO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                         â”‚
                                                    â”‚ 1. Consumer robusto     â”‚
                                                    â”‚    â€¢ Idempotencia       â”‚
                                                    â”‚    â€¢ Error handling     â”‚
                                                    â”‚    â€¢ ACK explÃ­cito      â”‚
                                                    â”‚                         â”‚
                                                    â”‚ 2. Actualiza inventario â”‚
                                                    â”‚    â€¢ Solo tras ACK      â”‚
                                                    â”‚    â€¢ Log de auditorÃ­a   â”‚
                                                    â”‚                         â”‚
                                                    â”‚ 3. Escalable           â”‚
                                                    â”‚    â€¢ MÃºltiples workers  â”‚
                                                    â”‚    â€¢ Load balancing     â”‚
                                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

BENEFICIOS ESPECÃFICOS OBTENIDOS:
âœ… Tiempo venta: 3-5s â†’ 50ms (95% mejora)
âœ… Disponibilidad: 98% â†’ 99.9% (10x mejora)  
âœ… PÃ©rdida mensajes: 2% â†’ 0.01% (200x mejora)
âœ… Escalabilidad: 1 sucursal â†’ N sucursales
â— Costo nuevo: Infraestructura + operaciÃ³n RabbitMQ
            </pre>
        </div>

        <div class="scenario-box">
            <h4>ğŸ“‹ Requerimientos EspecÃ­ficos que Cubre RabbitMQ:</h4>
            <ul>
                <li><strong>Durabilidad:</strong> Si el sistema se cae, los mensajes no se pierden</li>
                <li><strong>Acknowledgments:</strong> Solo procesa el mensaje si el consumer confirma Ã©xito</li>
                <li><strong>Prefetch Control:</strong> Evita sobrecargar consumers lentos</li>
                <li><strong>Dead Letter Queues:</strong> Maneja mensajes que fallan repetidamente</li>
                <li><strong>MÃºltiples Consumers:</strong> Escala horizontalmente cuando creces</li>
            </ul>
        </div>

        <div class="activity">
            <h3>ğŸš€ Actividad: Setup con Conciencia de ProducciÃ³n</h3>
            
            <h4>Setup Docker (10 min)</h4>
            <div class="code-block">
                <pre># docker-compose.yml - CON configuraciÃ³n de producciÃ³n
version: "3.9"
services:
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"     # AMQP
      - "15672:15672"   # Management UI
    environment:
      RABBITMQ_DEFAULT_USER: ecomarket_user      # NO uses guest en prod
      RABBITMQ_DEFAULT_PASS: ecomarket_password  # Cambiar en prod
      RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS: "-rabbit disk_free_limit 2GB"
    volumes:
      - ./rabbitmq_data:/var/lib/rabbitmq  # Persistencia
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 30s
      timeout: 10s
      retries: 5</pre>
            </div>

            <div class="tip">
                <h4>ğŸ’» Alternativa sin Docker</h4>
                <p>Si no tienes Docker disponible:</p>
                <ul>
                    <li><strong>Mac:</strong> <code>brew install rabbitmq</code> â†’ <code>brew services start rabbitmq</code></li>
                    <li><strong>Windows:</strong> <code>choco install rabbitmq</code> o descarga desde rabbitmq.com</li>
                    <li><strong>Linux:</strong> <code>sudo apt install rabbitmq-server</code> â†’ <code>sudo systemctl start rabbitmq-server</code></li>
                </ul>
                <p>Management UI: <code>sudo rabbitmq-plugins enable rabbitmq_management</code></p>
            </div>

            <p><strong>Â¿Por quÃ© esta configuraciÃ³n?</strong> Cada lÃ­nea resuelve un problema especÃ­fico de producciÃ³n.</p>
        </div>

        <div class="activity">
            <h3>ğŸ”§ Producer: Sucursal con GarantÃ­as</h3>
            <p>Tu publisher ahora tiene caracterÃ­sticas de producciÃ³n:</p>

            <div class="code-block">
                <pre>"""
Sucursal Publisher - CON garantÃ­as de entrega
"""
import pika
import json
import logging
from datetime import datetime
import uuid

def publish_sale_with_guarantees(sale_data: dict, max_retries: int = 3):
    """
    Publisher con TODAS las garantÃ­as que necesitamos:
    - Publisher confirms (RabbitMQ confirma que recibiÃ³)
    - Durable queue (sobrevive restart de RabbitMQ)  
    - Persistent messages (se guardan en disco)
    - Connection handling (reconexiÃ³n automÃ¡tica)
    """
    
    # Agregar metadata para tracking
    message = {
        **sale_data,
        "message_id": str(uuid.uuid4()),
        "timestamp": datetime.now().isoformat(),
        "source": "sucursal-001",
        "retry_count": 0
    }
    
    for attempt in range(max_retries):
        try:
            # ConexiÃ³n con parÃ¡metros de producciÃ³n
            params = pika.ConnectionParameters(
                host='localhost',
                port=5672,
                credentials=pika.PlainCredentials('ecomarket_user', 'ecomarket_password'),
                heartbeat=600,  # 10 min heartbeat
                blocked_connection_timeout=300,  # 5 min timeout
            )
            
            with pika.BlockingConnection(params) as connection:
                channel = connection.channel()
                
                # Declarar queue con durabilidad
                channel.queue_declare(
                    queue='sale_notifications',
                    durable=True,  # Sobrevive restart de RabbitMQ
                    arguments={
                        'x-max-retries': 3,
                        'x-message-ttl': 86400000,  # 24 horas TTL
                    }
                )
                
                # Habilitar publisher confirms
                channel.confirm_delivery()
                
                # Publicar con persistencia
                published = channel.basic_publish(
                    exchange='',
                    routing_key='sale_notifications',
                    body=json.dumps(message),
                    properties=pika.BasicProperties(
                        delivery_mode=2,  # Persistent
                        message_id=message["message_id"],
                        correlation_id=sale_data.get("sale_id"),
                        headers={'source': 'sucursal-001'}
                    ),
                    mandatory=True  # Falla si queue no existe
                )
                
                if published:
                    logger.info(f"âœ… Mensaje publicado exitosamente: {message['message_id']}")
                    return True
                else:
                    logger.warning(f"âš ï¸ RabbitMQ no confirmÃ³ el mensaje")
                    
        except Exception as e:
            logger.error(f"âŒ Intento {attempt + 1} fallÃ³: {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # Backoff exponencial
    
    logger.error(f"âŒ FallÃ³ publicar despuÃ©s de {max_retries} intentos")
    # En producciÃ³n: guardar en local DB para retry posterior
    return False</pre>
            </div>
            
            <div class="tip">
                <h4>ğŸš€ Teaser: Escalando para el Futuro</h4>
                <p><strong>Para 2000+ ventas/dÃ­a:</strong> Tu implementaciÃ³n actual es la base sÃ³lida. PrÃ³ximos pasos naturales:</p>
                <ul>
                    <li><strong>Cluster RabbitMQ:</strong> 3 nodos para alta disponibilidad</li>
                    <li><strong>HAProxy/Load Balancer:</strong> Distribuir carga entre consumers</li>
                    <li><strong>MÃºltiples workers:</strong> Horizontal scaling del processing</li>
                    <li><strong>Monitoreo:</strong> Prometheus + Grafana para mÃ©tricas</li>
                </ul>
                <p>Pero por ahora, enfÃ³cate en dominar los fundamentals ğŸ¯</p>
            </div>
        </div>

        <div class="activity">
            <h3>ğŸ“¥ Consumer: Central con Procesamiento Robusto</h3>

            <div class="code-block">
                <pre>"""
Central Consumer - CON procesamiento robusto
"""
import pika
import json
import logging
from typing import Set

# Para idempotencia (en prod: usar Redis o DB)
processed_messages: Set[str] = set()

def process_sale_message(ch, method, properties, body):
    """
    Consumer que maneja TODOS los edge cases:
    - Idempotencia (no procesar duplicados)
    - Error handling (ACK/NACK apropiado)
    - Logging para debugging
    - ValidaciÃ³n de datos
    """
    
    try:
        # Parsear mensaje
        message = json.loads(body)
        message_id = message.get('message_id')
        sale_id = message.get('sale_id')
        
        logger.info(f"ğŸ“¨ Recibido mensaje: {message_id} para venta {sale_id}")
        
        # Idempotencia: Â¿Ya procesamos este mensaje?
        if message_id in processed_messages:
            logger.info(f"â­ï¸ Mensaje duplicado ignorado: {message_id}")
            ch.basic_ack(delivery_tag=method.delivery_tag)
            return
        
        # Validar datos requeridos
        required_fields = ['sale_id', 'product_id', 'quantity_sold']
        if not all(field in message for field in required_fields):
            logger.error(f"âŒ Mensaje invÃ¡lido, faltan campos: {message}")
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
            return
        
        # Procesar lÃ³gica de negocio
        product_id = message['product_id']
        quantity = message['quantity_sold']
        
        if product_id in central_inventory:
            product = central_inventory[product_id]
            old_stock = product['stock']
            product['stock'] = max(0, product['stock'] - quantity)
            
            # Registrar como procesado
            processed_messages.add(message_id)
            
            logger.info(
                f"ğŸ“Š Inventario actualizado - {product['name']}: "
                f"{old_stock} â†’ {product['stock']} (mensaje: {message_id})"
            )
            
            # ACK explÃ­cito - solo despuÃ©s de procesamiento exitoso
            ch.basic_ack(delivery_tag=method.delivery_tag)
            
        else:
            logger.error(f"âŒ Producto {product_id} no encontrado")
            # NACK sin requeue para evitar loop infinito
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
            
    except json.JSONDecodeError as e:
        logger.error(f"âŒ JSON invÃ¡lido: {e}")
        ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
        
    except Exception as e:
        logger.error(f"âŒ Error procesando mensaje: {e}")
        # Requeue para reintentar (RabbitMQ maneja lÃ­mites)
        ch.basic_nack(delivery_tag=method.delivery_tag, requeue=True)

def start_consumer():
    """Consumer con configuraciÃ³n de producciÃ³n"""
    params = pika.ConnectionParameters(
        host='localhost',
        credentials=pika.PlainCredentials('ecomarket_user', 'ecomarket_password'),
        heartbeat=600,
    )
    
    connection = pika.BlockingConnection(params)
    channel = connection.channel()
    
    # Configurar queue con misma configuraciÃ³n que producer
    channel.queue_declare(queue='sale_notifications', durable=True)
    
    # QoS: procesar solo 1 mensaje a la vez
    channel.basic_qos(prefetch_count=1)
    
    # Configurar consumer
    channel.basic_consume(
        queue='sale_notifications',
        on_message_callback=process_sale_message,
        auto_ack=False  # ACK manual para garantÃ­as
    )
    
    logger.info("ğŸ§ Consumer iniciado, esperando mensajes...")
    try:
        channel.start_consuming()
    except KeyboardInterrupt:
        logger.info("ğŸ›‘ Deteniendo consumer...")
        channel.stop_consuming()
        connection.close()</pre>
            </div>
        </div>

        <div class="ai-prompt">
            <h4>ğŸ¤– Prompt para IA: AnÃ¡lisis de ImplementaciÃ³n</h4>
            <pre>Revisa mi implementaciÃ³n de RabbitMQ y evalÃºa si cubre mis requerimientos:

Mi cÃ³digo: [pegar implementaciÃ³n arriba]

Contexto de producciÃ³n:
- 400 ventas/dÃ­a actual, creciendo a 2000/dÃ­a
- MÃ¡ximo 1% de mensajes perdidos tolerable
- Equipo pequeÃ±o, necesita ser mantenible
- Budget limitado para infraestructura

EvalÃºa especÃ­ficamente:
1. Â¿Esta implementaciÃ³n garantiza que no pierdo mensajes?
2. Â¿QuÃ© pasa si RabbitMQ se reinicia mientras hay mensajes en cola?
3. Â¿CÃ³mo maneja duplicados si hay reconexiones?
4. Â¿EscalarÃ¡ para mi volumen proyectado?
5. Â¿QuÃ© problemas operacionales nuevos introduces?
6. Â¿Hay configuraciones crÃ­ticas que me faltan?

Para cada problema, dame:
- Por quÃ© es importante
- CÃ³mo se manifesta en producciÃ³n  
- CÃ³digo especÃ­fico para solucionarlo</pre>
        </div>

        <div class="checkpoint">
            <h3>âœ… Checkpoint de Fase 2</h3>
            <ul>
                <li>RabbitMQ corre con configuraciÃ³n de producciÃ³n</li>
                <li>Publisher usa confirms y mensajes persistentes</li>
                <li>Consumer maneja idempotencia y ACK explÃ­cito</li>
                <li>Puedo explicar cada configuraciÃ³n en tÃ©rminos de garantÃ­as de negocio (e.g., ACK = no pÃ©rdidas, durable = sobrevive restart, prefetch=1 = no sobrecarga)</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸ§ª">Fase 3: ValidaciÃ³n y Pruebas de Resiliencia (30 min)</h2>
        <p><strong>Objetivo de Aprendizaje:</strong> Demostrar que tu implementaciÃ³n realmente resuelve los problemas que identificaste en la Fase 0.</p>

        <div class="activity">
            <h3>ğŸ”¥ Pruebas de Caos Controlado</h3>
            <p>Vamos a simular exactamente los escenarios que motivaron usar RabbitMQ:</p>

            <div class="scenario-box">
                <h4>âš¡ Diagrama: Flujo de ValidaciÃ³n - Probando las GarantÃ­as</h4>
                <pre style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0;">
PRUEBA 1: PERSISTENCIA DURANTE REINICIO
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    publish     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    restart    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Sucursal â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚ RabbitMQ    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’   â”‚ RabbitMQ    â”‚
â”‚5 ventas â”‚                â”‚ (guardando) â”‚               â”‚ (recupera)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚                             â”‚
                                  â–¼                             â–¼
                           [5 mensajes                   [5 mensajes
                            en disco]                     intactos] â”€â”€â”€â”€â†’ Central
VALIDACIÃ“N: Â¿Se procesan todos sin pÃ©rdida? âœ…

PRUEBA 2: RESILIENCIA DEL CONSUMER  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    publish     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    consume    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Sucursal â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚ RabbitMQ    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚Central  â”‚
â”‚1 venta  â”‚                â”‚             â”‚               â”‚ (Ctrl+C)â”‚ âŒ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚                             â”‚
                                  â–¼                             â–¼
                           [Mensaje queda                [Sin ACK = 
                            en queue]                     mensaje vuelve]
                                  â”‚                             â”‚
                                  â–¼                             â–¼
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚ RabbitMQ    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚Central  â”‚
                           â”‚ (requeue)   â”‚                â”‚(restart)â”‚ âœ…
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
VALIDACIÃ“N: Â¿Se reprocesa automÃ¡ticamente? âœ…

PRUEBA 3: MANEJO DE VOLUMEN ALTO
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    20 ventas   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    procesa    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Sucursal â”‚ â•â•â•â•â•â•â•â•â•â•â•â†’   â”‚ RabbitMQ    â”‚ â”€â”€1 por 1â”€â”€â†’  â”‚Central  â”‚
â”‚paralelasâ”‚   simultÃ¡neas  â”‚ (prefetch=1)â”‚    ordenado   â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                            â”‚                            â”‚
     â–¼                            â–¼                            â–¼
[Todas completan           [Queue maneja            [Procesamiento
 en &lt;100ms]                 backpressure]            estable]
VALIDACIÃ“N: Â¿Sin pÃ©rdidas ni sobrecarga? âœ…

RESULTADO FINAL: SISTEMA ROBUSTO QUE CUMPLE PROMESAS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… Persistencia garantizada    âœ… Recovery automÃ¡tico
âœ… Procesamiento ordenado      âœ… Sin pÃ©rdida de datos  
âœ… Escalabilidad validada      âœ… ROI demostrado
                </pre>
            </div>

            <h4>Prueba 1: Persistencia Durante Reinicio (10 min)</h4>
            <ol>
                <li>EnvÃ­a 5 mensajes desde la sucursal</li>
                <li>Antes de que el consumer los procese, detÃ©n RabbitMQ: <code>docker stop rabbitmq</code></li>
                <li>Reinicia RabbitMQ: <code>docker start rabbitmq</code></li>
                <li>Inicia el consumer</li>
                <li><strong>Resultado esperado:</strong> Los 5 mensajes se procesan sin pÃ©rdida</li>
            </ol>

            <h4>Prueba 2: Resiliencia del Consumer (10 min)</h4>
            <ol>
                <li>Inicia el consumer</li>
                <li>EnvÃ­a un mensaje</li>
                <li>Mata el proceso del consumer (Ctrl+C) ANTES de que termine de procesar</li>
                <li>Reinicia el consumer</li>
                <li><strong>Resultado esperado:</strong> El mensaje se reprocesa automÃ¡ticamente</li>
            </ol>

            <h4>Prueba 3: Manejo de Volumen (10 min)</h4>
            <div class="code-block">
                <pre># Script de carga bÃ¡sico (para aprendizaje)
import asyncio
import httpx

async def load_test_simple():
    async with httpx.AsyncClient() as client:
        tasks = []
        for i in range(20):  # 20 ventas simultÃ¡neas
            task = client.post(
                "http://localhost:8001/sales",
                json={"product_id": 1, "quantity": 1}
            )
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        successes = len([r for r in results if not isinstance(r, Exception)])
        print(f"âœ… Completadas: {successes}/20")

# Ejecutar: python -c "import asyncio; asyncio.run(load_test_simple())"</pre>
            </div>
            
            <div class="tip">
                <h4>ğŸš€ Para Pruebas de Carga Realistas (ProducciÃ³n)</h4>
                <p>El script anterior es pedagÃ³gico. Para simular 100+ usuarios simultÃ¡neos:</p>
                <div class="code-block">
                    <pre># Instalar: pip install locust
# Archivo: locustfile.py
from locust import HttpUser, task, between

class EcoMarketUser(HttpUser):
    wait_time = between(1, 3)  # 1-3s entre requests
    
    @task
    def make_sale(self):
        self.client.post("/sales", json={
            "product_id": 1,
            "quantity": 1
        })

# Ejecutar: locust -f locustfile.py
# UI en http://localhost:8089 - configura 100 users, 10/s spawn rate</pre>
                </div>
                <p><strong>Beneficio:</strong> VisualizaciÃ³n en tiempo real de throughput, latencias p95/p99, y error rate bajo carga.</p>
            </div>
            
            <p><strong>Resultado esperado:</strong> Todas las ventas se completan rÃ¡pidamente, mensajes se procesan ordenadamente</p>
        </div>

        <div class="reflection">
            <h3>ğŸ“Š MÃ©tricas de ValidaciÃ³n</h3>
            <p>Compara el sistema anterior vs RabbitMQ:</p>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>MÃ©trica</th>
                        <th>HTTP Directo</th>
                        <th>Con RabbitMQ</th>
                        <th>Mejora</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Tiempo de venta</td>
                        <td>3-5 segundos</td>
                        <td>&lt;100ms</td>
                        <td>95% mÃ¡s rÃ¡pido</td>
                    </tr>
                    <tr>
                        <td>Disponibilidad</td>
                        <td>98% (falla con central caÃ­do)</td>
                        <td>99.9% (venta siempre disponible)</td>
                        <td>10x mejor</td>
                    </tr>
                    <tr>
                        <td>Mensajes perdidos</td>
                        <td>2-3% en fallos de red</td>
                        <td>&lt;0.1% (solo en fallos graves)</td>
                        <td>20x mÃ¡s confiable</td>
                    </tr>
                    <tr>
                        <td>Complejidad operacional</td>
                        <td>Baja</td>
                        <td>Media (RabbitMQ + monitoring)</td>
                        <td>Costo aceptable</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="tip">
            <h3>ğŸ¯ ROI Demostrado</h3>
            <p>Con los nÃºmeros de la Fase 0:</p>
            <ul>
                <li><strong>Antes:</strong> $1,440 perdidos por cada 8 minutos de caÃ­da</li>
                <li><strong>DespuÃ©s:</strong> $0 perdidos en ventas durante caÃ­das (las ventas se procesan localmente)</li>
                <li><strong>Costo de implementaciÃ³n:</strong> ~40 horas de desarrollo</li>
                <li><strong>Payback:</strong> Se paga en la primera caÃ­da evitada</li>
            </ul>
        </div>

        <div class="checkpoint">
            <h3>âœ… Checkpoint Final</h3>
            <ul>
                <li>Todas las pruebas de caos pasaron exitosamente</li>
                <li>Puedo demostrar ROI cuantificable vs sistema anterior</li>
                <li>Entiendo quÃ© problemas nuevos introduce RabbitMQ y cÃ³mo monitearlos</li>
                <li>Tengo un plan para operaciÃ³n y escalamiento</li>
            </ul>
        </div>
    </div>

    <div class="phase">
        <h2 data-icon="ğŸš€">ReflexiÃ³n Final: El Verdadero Aprendizaje</h2>
        
        <div class="reflection">
            <h3>ğŸ¤” Preguntas Profundas para tu Equipo</h3>
            <ol>
                <li><strong>EvoluciÃ³n vs RevoluciÃ³n:</strong> Â¿Por quÃ© es importante evolucionar paso a paso en lugar de saltar directo a la soluciÃ³n "perfecta"?</li>
                <li><strong>Complejidad Justificada:</strong> Â¿En quÃ© momento exacto la complejidad adicional de RabbitMQ se vuelve valiosa vs el costo?</li>
                <li><strong>Patrones Universales:</strong> Â¿QuÃ© otros problemas en tu trabajo actual podrÃ­an beneficiarse de este mismo journey evolutivo?</li>
                <li><strong>Decisiones de Arquitectura:</strong> Â¿CÃ³mo cambiarÃ­an estas decisiones si fueras una startup de 5 personas vs una empresa de 500?</li>
            </ol>
        </div>

        <div class="ai-prompt">
            <h4>ğŸ¤– Prompt Final: SÃ­ntesis de Aprendizaje</h4>
            <pre>AyÃºdame a sintetizar lo que aprendÃ­ sobre toma de decisiones arquitectÃ³nicas:

Mi journey:
1. EmpecÃ© con: [HTTP directo]
2. IdentifiquÃ© problemas: [fallos 2%, $X perdidos/mes]
3. ExplorÃ© alternativas: [retry, backoff, Redis, RabbitMQ]
4. ElegÃ­: [RabbitMQ] por: [razones especÃ­ficas]
5. ImplementÃ© con: [garantÃ­as de producciÃ³n]
6. ValidÃ© que resuelve: [problemas originales]

Reflexiones para extraer:
1. Â¿QuÃ© principios generales puedo aplicar a otras decisiones tÃ©cnicas?
2. Â¿CÃ³mo balanceo complejidad vs beneficio en el futuro?
3. Â¿QuÃ© preguntas debo hacerme antes de adoptar cualquier tecnologÃ­a nueva?
4. Â¿CÃ³mo comunico este tipo de decisiones a stakeholders no tÃ©cnicos?

Dame un framework mental que pueda reutilizar para cualquier decisiÃ³n arquitectÃ³nica futura.</pre>
        </div>
        
        <div class="decision-matrix">
            <h4>ğŸ“‹ Framework Mental de Output (Ejemplo de respuesta del prompt anterior):</h4>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Principio</th>
                        <th>Pregunta GuÃ­a</th>
                        <th>Ejemplo de EcoMarket</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Cuantificar Dolor</strong></td>
                        <td>Â¿$X/mes perdido? Â¿EscalarÃ¡?</td>
                        <td>$1,440/dÃ­a en fallos â†’ $43,200/mes</td>
                    </tr>
                    <tr>
                        <td><strong>Evaluar Alternativas</strong></td>
                        <td>Â¿Escala 5x? Â¿DÃ³nde falla?</td>
                        <td>Retry OK now, RabbitMQ for growth</td>
                    </tr>
                    <tr>
                        <td><strong>Validar ROI</strong></td>
                        <td>Â¿Payback <3 meses?</td>
                        <td>SÃ­, primera caÃ­da evitada paga implementaciÃ³n</td>
                    </tr>
                    <tr>
                        <td><strong>Implementar Incremental</strong></td>
                        <td>Â¿Puedo probar con PoC?</td>
                        <td>EmpecÃ© con retry simple, evolucione paso a paso</td>
                    </tr>
                    <tr>
                        <td><strong>Medir Impacto Real</strong></td>
                        <td>Â¿Cumple promesas originales?</td>
                        <td>98% â†’ 99.9% disponibilidad validada empÃ­ricamente</td>
                    </tr>
                </tbody>
            </table>
            <p><em>Este framework es transferible a: Database scaling, caching strategies, authentication systems, etc.</em></p>
        </div>

        <div class="tip">
            <h3>ğŸ“ El Verdadero Valor</h3>
            <p>No has aprendido solo RabbitMQ. Has aprendido:</p>
            <ul>
                <li><strong>MetodologÃ­a:</strong> CÃ³mo evaluar y evolucionar soluciones incrementalmente</li>
                <li><strong>JustificaciÃ³n:</strong> CÃ³mo cuantificar el valor vs costo de decisiones tÃ©cnicas</li>
                <li><strong>ImplementaciÃ³n:</strong> CÃ³mo construir sistemas con caracterÃ­sticas de producciÃ³n</li>
                <li><strong>ValidaciÃ³n:</strong> CÃ³mo demostrar que una soluciÃ³n realmente resuelve el problema</li>
            </ul>
            <p><strong>Esto es transferible a cualquier decisiÃ³n arquitectÃ³nica futura.</strong></p>
        </div>
    </div>

    <p style="text-align: center; margin-top: 30px;">
        ğŸ‰ Â¡Felicitaciones! Ahora sabes no solo CÃ“MO implementar colas de mensajes, sino CUÃNDO y POR QUÃ‰ hacerlo.
    </p>
</body>
</html>